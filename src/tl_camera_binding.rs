#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]

/* automatically generated by rust-bindgen 0.71.1 */

pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of max_align_t"][::std::mem::size_of::<max_align_t>() - 32usize];
    ["Alignment of max_align_t"][::std::mem::align_of::<max_align_t>() - 16usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce1"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce1) - 0usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce2"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce2) - 16usize];
};
#[doc = "< A red pixel."]
pub const TL_COLOR_FILTER_ARRAY_PHASE_TL_COLOR_FILTER_ARRAY_PHASE_BAYER_RED:
    TL_COLOR_FILTER_ARRAY_PHASE = 0;
#[doc = "< A blue pixel."]
pub const TL_COLOR_FILTER_ARRAY_PHASE_TL_COLOR_FILTER_ARRAY_PHASE_BAYER_BLUE:
    TL_COLOR_FILTER_ARRAY_PHASE = 1;
#[doc = "< A green pixel next to a red pixel."]
pub const TL_COLOR_FILTER_ARRAY_PHASE_TL_COLOR_FILTER_ARRAY_PHASE_BAYER_GREEN_LEFT_OF_RED:
    TL_COLOR_FILTER_ARRAY_PHASE = 2;
#[doc = "< A green pixel next to a blue pixel."]
pub const TL_COLOR_FILTER_ARRAY_PHASE_TL_COLOR_FILTER_ARRAY_PHASE_BAYER_GREEN_LEFT_OF_BLUE:
    TL_COLOR_FILTER_ARRAY_PHASE = 3;
#[doc = "< A sentinel value (DO NOT USE)."]
pub const TL_COLOR_FILTER_ARRAY_PHASE_TL_COLOR_FILTER_ARRAY_PHASE_MAX: TL_COLOR_FILTER_ARRAY_PHASE =
    4;
#[doc = " The TL_COLOR_FILTER_ARRAY_PHASE enumeration lists all the possible values\n   that a pixel in a Bayer pattern color arrangement could assume.\n\n   The classic Bayer pattern is\n\n   <pre>\n   -----------------------\n   |          |          |\n   |    R     |    GR    |\n   |          |          |\n   -----------------------\n   |          |          |\n   |    GB    |    B     |\n   |          |          |\n   -----------------------\n   </pre>\n\n   where:\n\n   - R = a red pixel\n   - GR = a green pixel next to a red pixel\n   - B = a blue pixel\n   - GB = a green pixel next to a blue pixel\n\n   The primitive pattern shown above represents the fundamental color pixel arrangement in a Bayer pattern\n   color sensor.  The basic pattern would extend in the X and Y directions in a real color sensor containing\n   millions of pixels.\n\n   Notice that the color of the origin (0, 0) pixel logically determines the color of every other pixel.\n\n   It is for this reason that the color of this origin pixel is termed the color \"phase\" because it represents\n   the reference point for the color determination of all other pixels.\n\n   Every TSI color camera provides the sensor specific color phase of the full frame origin pixel as a discoverable parameter."]
pub type TL_COLOR_FILTER_ARRAY_PHASE = ::std::os::raw::c_uint;
#[doc = "< The color pixels blue, green, and red are grouped in separate planes in the buffer: BBBBBBBB..., GGGGGGGG..., RRRRRRRR...."]
pub const TL_COLOR_FORMAT_TL_COLOR_FORMAT_BGR_PLANAR: TL_COLOR_FORMAT = 0;
#[doc = "< The color pixels blue, green, and red are clustered and stored consecutively in the following pattern: BGRBGRBGR..."]
pub const TL_COLOR_FORMAT_TL_COLOR_FORMAT_BGR_PIXEL: TL_COLOR_FORMAT = 1;
#[doc = "< The color pixels blue, green, and red are clustered and stored consecutively in the following pattern: RGBRGBRGB..."]
pub const TL_COLOR_FORMAT_TL_COLOR_FORMAT_RGB_PIXEL: TL_COLOR_FORMAT = 2;
#[doc = "< A sentinel value (DO NOT USE)."]
pub const TL_COLOR_FORMAT_TL_COLOR_FORMAT_MAX: TL_COLOR_FORMAT = 3;
#[doc = " The TL_COLOR_FORMAT enumeration lists all the possible options for specifying the order of\n   color pixels in input and/or output buffers.\n\n   This enumeration appears as an argument in certain API functions across the different\n   color modules that a programmer must specify to determine the behavior of that function.\n\n   Depending on the context, it can specify\n   - the desired pixel order that a module must use when writing color pixel data into an output buffer\n   - the pixel order that a module must use to interpret data in an input buffer."]
pub type TL_COLOR_FORMAT = ::std::os::raw::c_uint;
#[doc = "< A Bayer pattern color sensor."]
pub const TL_COLOR_FILTER_TYPE_TL_COLOR_FILTER_TYPE_BAYER: TL_COLOR_FILTER_TYPE = 0;
#[doc = "< A sentinel value (DO NOT USE)."]
pub const TL_COLOR_FILTER_TYPE_TL_COLOR_FILTER_TYPE_MAX: TL_COLOR_FILTER_TYPE = 1;
#[doc = " The TL_COLOR_FILTER_TYPE enumeration lists all the possible types of color sensor pixel\n   arrangements that can be found in TSI's color camera product line.\n\n   Every TSI color camera provides the color filter type of its sensor as a discoverable parameter."]
pub type TL_COLOR_FILTER_TYPE = ::std::os::raw::c_uint;
#[doc = "< 0 degrees polarization phase"]
pub const TL_POLARIZATION_PROCESSOR_POLAR_PHASE_TL_POLARIZATION_PROCESSOR_POLAR_PHASE_0_DEGREES:
    TL_POLARIZATION_PROCESSOR_POLAR_PHASE = 0;
#[doc = "< 45 degrees polarization phase"]
pub const TL_POLARIZATION_PROCESSOR_POLAR_PHASE_TL_POLARIZATION_PROCESSOR_POLAR_PHASE_45_DEGREES:
    TL_POLARIZATION_PROCESSOR_POLAR_PHASE = 1;
#[doc = "< 90 degrees polarization phase"]
pub const TL_POLARIZATION_PROCESSOR_POLAR_PHASE_TL_POLARIZATION_PROCESSOR_POLAR_PHASE_90_DEGREES:
    TL_POLARIZATION_PROCESSOR_POLAR_PHASE = 2;
#[doc = "< 135 (-45) degrees polarization phase"]
pub const TL_POLARIZATION_PROCESSOR_POLAR_PHASE_TL_POLARIZATION_PROCESSOR_POLAR_PHASE_135_DEGREES : TL_POLARIZATION_PROCESSOR_POLAR_PHASE = 3 ;
#[doc = "< A sentinel value (DO NOT USE)."]
pub const TL_POLARIZATION_PROCESSOR_POLAR_PHASE_TL_POLARIZATION_PROCESSOR_POLAR_PHASE_MAX:
    TL_POLARIZATION_PROCESSOR_POLAR_PHASE = 4;
#[doc = " The TL_POLARIZATION_PROCESSOR_POLAR_PHASE enumeration lists all the possible values (in degrees)\n   that a pixel in a polarization sensor could assume.\n\n   The polarization phase pattern is\n\n   <pre>\n   -----------------------\n   |          |          |\n   |    0     |   -45    |\n   |          |          |\n   -----------------------\n   |          |          |\n   |    45    |    90    |\n   |          |          |\n   -----------------------\n   </pre>\n\n\n   The primitive pattern shown above represents the fundamental polarization phase arrangement in a polarization\n   sensor.  The basic pattern would extend in the X and Y directions in a real polarization sensor containing\n   millions of pixels.\n\n   Notice that the phase of the origin (0, 0) pixel logically determines the phase of every other pixel.\n\n   It is for this reason that the phase of this origin pixel is termed the polarization \"phase\" because it represents\n   the reference point for the phase determination of all other pixels.\n\n   Every TSI polarization camera provides the sensor specific polarization phase of the full frame origin pixel as a discoverable parameter."]
pub type TL_POLARIZATION_PROCESSOR_POLAR_PHASE = ::std::os::raw::c_uint;
#[doc = " <summary>\n     The camera uses the GigE Vision (GigE) interface standard.\n </summary>"]
pub const TL_CAMERA_COMMUNICATION_INTERFACE_TL_CAMERA_COMMUNICATION_INTERFACE_GIG_E:
    TL_CAMERA_COMMUNICATION_INTERFACE = 0;
#[doc = " <summary>\n     The camera uses the CameraLink serial-communication-protocol standard.\n </summary>"]
pub const TL_CAMERA_COMMUNICATION_INTERFACE_TL_CAMERA_COMMUNICATION_INTERFACE_CAMERA_LINK:
    TL_CAMERA_COMMUNICATION_INTERFACE = 1;
#[doc = " <summary>\n     The camera uses a USB interface.\n </summary>"]
pub const TL_CAMERA_COMMUNICATION_INTERFACE_TL_CAMERA_COMMUNICATION_INTERFACE_USB:
    TL_CAMERA_COMMUNICATION_INTERFACE = 2;
#[doc = " <summary>\n     Marks the end of the enumeration. Do not use.\n </summary>"]
pub const TL_CAMERA_COMMUNICATION_INTERFACE_TL_CAMERA_COMMUNICATION_INTERFACE_MAX:
    TL_CAMERA_COMMUNICATION_INTERFACE = 3;
#[doc = " <summary>\n     The TL_CAMERA_COMMUNICATION_INTERFACE enumeration defines the values the SDK uses for specifying the physical camera interface.\n </summary>"]
pub type TL_CAMERA_COMMUNICATION_INTERFACE = ::std::os::raw::c_uint;
#[doc = " <summary>\n     Sets the device to an image readout frequency of 20 MHz.\n </summary>"]
pub const TL_CAMERA_DATA_RATE_TL_CAMERA_DATA_RATE_READOUT_FREQUENCY_20: TL_CAMERA_DATA_RATE = 0;
#[doc = " <summary>\n     Sets the device to an image readout frequency of 40 MHz.\n </summary>"]
pub const TL_CAMERA_DATA_RATE_TL_CAMERA_DATA_RATE_READOUT_FREQUENCY_40: TL_CAMERA_DATA_RATE = 1;
#[doc = " <summary>\n     Sets the device to deliver images at 30 frames per second.\n </summary>"]
pub const TL_CAMERA_DATA_RATE_TL_CAMERA_DATA_RATE_FPS_30: TL_CAMERA_DATA_RATE = 2;
#[doc = " <summary>\n     Sets the device to deliver images at 50 frames per second.\n </summary>"]
pub const TL_CAMERA_DATA_RATE_TL_CAMERA_DATA_RATE_FPS_50: TL_CAMERA_DATA_RATE = 3;
#[doc = " <summary>\n     Marks the end of the enumeration. Do not use.\n </summary>"]
pub const TL_CAMERA_DATA_RATE_TL_CAMERA_DATA_RATE_MAX: TL_CAMERA_DATA_RATE = 4;
#[doc = " <summary>\n     The TL_CAMERA_DATA_RATE enumeration defines the options\n     for setting the desired image data delivery rate.\n </summary>"]
pub type TL_CAMERA_DATA_RATE = ::std::os::raw::c_uint;
#[doc = " <summary>\n     EEP mode is disabled.\n </summary>"]
pub const TL_CAMERA_EEP_STATUS_TL_CAMERA_EEP_STATUS_DISABLED: TL_CAMERA_EEP_STATUS = 0;
#[doc = " <summary>\n     EEP mode is enabled and currently active.\n </summary>"]
pub const TL_CAMERA_EEP_STATUS_TL_CAMERA_EEP_STATUS_ENABLED_ACTIVE: TL_CAMERA_EEP_STATUS = 1;
#[doc = " <summary>\n     EEP mode is enabled, but due to an unsupported exposure value, currently inactive.\n </summary>"]
pub const TL_CAMERA_EEP_STATUS_TL_CAMERA_EEP_STATUS_ENABLED_INACTIVE: TL_CAMERA_EEP_STATUS = 2;
#[doc = " <summary>\n     EEP mode is enabled in bulb mode.\n </summary>"]
pub const TL_CAMERA_EEP_STATUS_TL_CAMERA_EEP_STATUS_ENABLED_BULB: TL_CAMERA_EEP_STATUS = 3;
#[doc = " <summary>\n     Marks the end of the enumeration. Do not use.\n </summary>"]
pub const TL_CAMERA_EEP_STATUS_TL_CAMERA_EEP_STATUS_MAX: TL_CAMERA_EEP_STATUS = 4;
#[doc = " <summary>\n     The TL_CAMERA_EEP_STATUS enumeration defines the options\n     available for specifying the device's EEP mode.\n     Equal Exposure Pulse (EEP) mode is an LVTTL-level signal\n     that is active during the time when all rows have been\n     reset during rolling reset, and the end of the exposure time\n     (and the beginning of rolling readout).  The signal\n     can be used to control an external light source that will be\n     on only during the equal exposure period, providing\n     the same amount of exposure for all pixels in the ROI.\\n\\n\n     When EEP mode is disabled, the status will always be EEPStatus.Off.\\n\n     EEP mode can be enabled, but, depending on the exposure\n     value, active or inactive.\\n\n     If EEP is enabled in bulb mode, it will always give a status of Bulb.\n </summary>"]
pub type TL_CAMERA_EEP_STATUS = ::std::os::raw::c_uint;
#[doc = " <summary>\n     The command request to the camera succeeded with no errors.\n </summary>"]
pub const TL_CAMERA_ERROR_TL_CAMERA_ERROR_NONE: TL_CAMERA_ERROR = 0;
#[doc = " <summary>\n     The camera received an unknown command.\n </summary>"]
pub const TL_CAMERA_ERROR_TL_CAMERA_ERROR_COMMAND_NOT_FOUND: TL_CAMERA_ERROR = 1;
#[doc = " <summary>\n     The camera encountered too MANY arguments for the specified command.\n </summary>"]
pub const TL_CAMERA_ERROR_TL_CAMERA_ERROR_TOO_MANY_ARGUMENTS: TL_CAMERA_ERROR = 2;
#[doc = " <summary>\n     The camera encountered too FEW arguments for the specified command.\n </summary>"]
pub const TL_CAMERA_ERROR_TL_CAMERA_ERROR_NOT_ENOUGH_ARGUMENTS: TL_CAMERA_ERROR = 3;
#[doc = " <summary>\n     The camera received an invalid command.\n </summary>"]
pub const TL_CAMERA_ERROR_TL_CAMERA_ERROR_INVALID_COMMAND: TL_CAMERA_ERROR = 4;
#[doc = " <summary>\n     The camera received a duplicate command.\n </summary>"]
pub const TL_CAMERA_ERROR_TL_CAMERA_ERROR_DUPLICATE_COMMAND: TL_CAMERA_ERROR = 5;
#[doc = " <summary>\n     The camera received a command that is not documented in JSON.\n </summary>"]
pub const TL_CAMERA_ERROR_TL_CAMERA_ERROR_MISSING_JSON_COMMAND: TL_CAMERA_ERROR = 6;
#[doc = " <summary>\n     The camera rejected the request because the it is being initialized.\n </summary>"]
pub const TL_CAMERA_ERROR_TL_CAMERA_ERROR_INITIALIZING: TL_CAMERA_ERROR = 7;
#[doc = " <summary>\n     The user specified an unsupported and/or unknown command argument.\n </summary>"]
pub const TL_CAMERA_ERROR_TL_CAMERA_ERROR_NOTSUPPORTED: TL_CAMERA_ERROR = 8;
#[doc = " <summary>\n     The camera rejected the request because the FPGA has not been programmed with a firmware image.\n </summary>"]
pub const TL_CAMERA_ERROR_TL_CAMERA_ERROR_FPGA_NOT_PROGRAMMED: TL_CAMERA_ERROR = 9;
#[doc = " <summary>\n     The user specified an invalid ROI width.\n </summary>"]
pub const TL_CAMERA_ERROR_TL_CAMERA_ERROR_ROI_WIDTH_ERROR: TL_CAMERA_ERROR = 10;
#[doc = " <summary>\n     The user specified an invalid ROI range.\n </summary>"]
pub const TL_CAMERA_ERROR_TL_CAMERA_ERROR_ROI_RANGE_ERROR: TL_CAMERA_ERROR = 11;
#[doc = " <summary>\n     The user specified an invalid range for the specified command.\n </summary>"]
pub const TL_CAMERA_ERROR_TL_CAMERA_ERROR_RANGE_ERROR: TL_CAMERA_ERROR = 12;
#[doc = " <summary>\n     The camera rejected the request because use of the specified command is restricted.\n </summary>"]
pub const TL_CAMERA_ERROR_TL_CAMERA_ERROR_COMMAND_LOCKED: TL_CAMERA_ERROR = 13;
#[doc = " <summary>\n     The camera rejected the request because the specified command can only be accepted when the camera is stopped.\n </summary>"]
pub const TL_CAMERA_ERROR_TL_CAMERA_ERROR_CAMERA_MUST_BE_STOPPED: TL_CAMERA_ERROR = 14;
#[doc = " <summary>\n     The camera encountered an ROI/binning error.\n </summary>"]
pub const TL_CAMERA_ERROR_TL_CAMERA_ERROR_ROI_BIN_COMBO_ERROR: TL_CAMERA_ERROR = 15;
#[doc = " <summary>\n     The camera encountered an image data sync error.\n </summary>"]
pub const TL_CAMERA_ERROR_TL_CAMERA_ERROR_IMAGE_DATA_SYNC_ERROR: TL_CAMERA_ERROR = 16;
#[doc = " <summary>\n     The camera rejected the request because the specified command can only be accepted when the camera is disarmed.\n </summary>"]
pub const TL_CAMERA_ERROR_TL_CAMERA_ERROR_CAMERA_MUST_BE_DISARMED: TL_CAMERA_ERROR = 17;
#[doc = " <summary>\n     Marks the end of the enumeration. Do not use.\n </summary>"]
pub const TL_CAMERA_ERROR_TL_CAMERA_ERROR_MAX_ERRORS: TL_CAMERA_ERROR = 18;
#[doc = " <summary>\n     The CAMERA_ERROR enumeration defines tl_camera_sdk error codes that can be returned from function calls.\\n\\n\n </summary>"]
pub type TL_CAMERA_ERROR = ::std::os::raw::c_uint;
#[doc = " <summary>\n     Use software operation mode to generate one or more frames per trigger or to run continuous video mode.\n </summary>"]
pub const TL_CAMERA_OPERATION_MODE_TL_CAMERA_OPERATION_MODE_SOFTWARE_TRIGGERED:
    TL_CAMERA_OPERATION_MODE = 0;
#[doc = " <summary>\n     Use hardware triggering to generate one or more frames per trigger by issuing hardware signals.\n </summary>"]
pub const TL_CAMERA_OPERATION_MODE_TL_CAMERA_OPERATION_MODE_HARDWARE_TRIGGERED:
    TL_CAMERA_OPERATION_MODE = 1;
#[doc = " <summary>\n     Use bulb-mode triggering to generate one or more frames per trigger by issuing hardware signals. Please refer to the camera manual for signaling details.\n </summary>"]
pub const TL_CAMERA_OPERATION_MODE_TL_CAMERA_OPERATION_MODE_BULB: TL_CAMERA_OPERATION_MODE = 2;
#[doc = " <summary>\n     Reserved for internal use.\n </summary>"]
pub const TL_CAMERA_OPERATION_MODE_TL_CAMERA_OPERATION_MODE_RESERVED1: TL_CAMERA_OPERATION_MODE = 3;
#[doc = " <summary>\n     Reserved for internal use.\n </summary>"]
pub const TL_CAMERA_OPERATION_MODE_TL_CAMERA_OPERATION_MODE_RESERVED2: TL_CAMERA_OPERATION_MODE = 4;
#[doc = " <summary>\n     Marks the end of the enumeration. Do not use.\n </summary>"]
pub const TL_CAMERA_OPERATION_MODE_TL_CAMERA_OPERATION_MODE_MAX: TL_CAMERA_OPERATION_MODE = 5;
#[doc = " <summary>\n The TL_CAMERA_OPERATION_MODE enumeration defines the available mode for camera. To determine\n which modes a camera supports, use tl_camera_get_is_operation_mode_supported().\n </summary>"]
pub type TL_CAMERA_OPERATION_MODE = ::std::os::raw::c_uint;
#[doc = " <summary>\n    Each pixel of the sensor indicates an intensity.\n </summary>"]
pub const TL_CAMERA_SENSOR_TYPE_TL_CAMERA_SENSOR_TYPE_MONOCHROME: TL_CAMERA_SENSOR_TYPE = 0;
#[doc = " <summary>\n     The sensor has a bayer-patterned filter overlaying it, allowing the camera SDK to distinguish red, green, and blue values.\n </summary>"]
pub const TL_CAMERA_SENSOR_TYPE_TL_CAMERA_SENSOR_TYPE_BAYER: TL_CAMERA_SENSOR_TYPE = 1;
#[doc = " <summary>\n     The sensor has a polarization filter overlaying it allowing the camera to capture polarization information from the incoming light.\n </summary>"]
pub const TL_CAMERA_SENSOR_TYPE_TL_CAMERA_SENSOR_TYPE_MONOCHROME_POLARIZED: TL_CAMERA_SENSOR_TYPE =
    2;
#[doc = " <summary>\n     Marks the end of the enumeration. Do not use.\n </summary>"]
pub const TL_CAMERA_SENSOR_TYPE_TL_CAMERA_SENSOR_TYPE_MAX: TL_CAMERA_SENSOR_TYPE = 3;
#[doc = " <summary>\n This describes the physical capabilities of the camera sensor.\n </summary>"]
pub type TL_CAMERA_SENSOR_TYPE = ::std::os::raw::c_uint;
#[doc = " <summary>\n     Charges are read out through a single analog-to-digital converter.\n </summary>"]
pub const TL_CAMERA_TAPS_TL_CAMERA_TAPS_SINGLE_TAP: TL_CAMERA_TAPS = 0;
#[doc = " <summary>\n     Charges are read out through two analog-to-digital converters.\n </summary>"]
pub const TL_CAMERA_TAPS_TL_CAMERA_TAPS_DUAL_TAP: TL_CAMERA_TAPS = 1;
#[doc = " <summary>\n     Charges are read out through four analog-to-digital converters.\n </summary>"]
pub const TL_CAMERA_TAPS_TL_CAMERA_TAPS_QUAD_TAP: TL_CAMERA_TAPS = 2;
#[doc = " <summary>\n     Marks the end of the enumeration. Do not use.\n </summary>"]
pub const TL_CAMERA_TAPS_TL_CAMERA_TAPS_MAX_TAP: TL_CAMERA_TAPS = 3;
#[doc = " <summary>\n     Scientific CCD cameras support one or more taps.\\n\\n\n     After exposure is complete, a CCD pixel array holds the charge corresponding to the amount of light collected at\n     each pixel location. The data is then read out through 1, 2, or 4 channels at a time.\n </summary>"]
pub type TL_CAMERA_TAPS = ::std::os::raw::c_uint;
#[doc = " <summary>\n     Acquire an image on the RISING edge of the trigger pulse.\n </summary>"]
pub const TL_CAMERA_TRIGGER_POLARITY_TL_CAMERA_TRIGGER_POLARITY_ACTIVE_HIGH:
    TL_CAMERA_TRIGGER_POLARITY = 0;
#[doc = " <summary>\n     Acquire an image on the FALLING edge of the trigger pulse.\n </summary>"]
pub const TL_CAMERA_TRIGGER_POLARITY_TL_CAMERA_TRIGGER_POLARITY_ACTIVE_LOW:
    TL_CAMERA_TRIGGER_POLARITY = 1;
#[doc = " <summary>\n     Marks the end of the enumeration. Do not use.\n </summary>"]
pub const TL_CAMERA_TRIGGER_POLARITY_TL_CAMERA_TRIGGER_POLARITY_MAX: TL_CAMERA_TRIGGER_POLARITY = 2;
#[doc = " <summary>\n The TRIGGER_POLARITY enumeration defines the options available for specifying the hardware trigger polarity.\\n\\n\n These values specify which edge of the input trigger pulse that will initiate image acquisition.\n </summary>"]
pub type TL_CAMERA_TRIGGER_POLARITY = ::std::os::raw::c_uint;
#[doc = " <summary>\n     The device is connected to a USB 1.0/1.1 port (1.5 Mbits/sec or 12 Mbits/sec).\n </summary>"]
pub const TL_CAMERA_USB_PORT_TYPE_TL_CAMERA_USB_PORT_TYPE_USB1_0: TL_CAMERA_USB_PORT_TYPE = 0;
#[doc = " <summary>\n     The device is connected to a USB 2.0 port (480 Mbits/sec).\n </summary>"]
pub const TL_CAMERA_USB_PORT_TYPE_TL_CAMERA_USB_PORT_TYPE_USB2_0: TL_CAMERA_USB_PORT_TYPE = 1;
#[doc = " <summary>\n     The device is connected to a USB 3.0 port (5000 Mbits/sec).\n </summary>"]
pub const TL_CAMERA_USB_PORT_TYPE_TL_CAMERA_USB_PORT_TYPE_USB3_0: TL_CAMERA_USB_PORT_TYPE = 2;
#[doc = " <summary>\n     Marks the end of the enumeration. Do not use.\n </summary>"]
pub const TL_CAMERA_USB_PORT_TYPE_TL_CAMERA_USB_PORT_TYPE_MAX: TL_CAMERA_USB_PORT_TYPE = 3;
#[doc = " <summary>\n The TL_CAMERA_USB_PORT_TYPE enumeration defines the values the SDK uses for specifying the USB bus speed.\\n\\n\n These values are returned by SDK API functions and callbacks based on the type of physical USB port that the device is connected to.\n </summary>"]
pub type TL_CAMERA_USB_PORT_TYPE = ::std::os::raw::c_uint;
#[doc = " @cond HIDDEN_VARIABLES  // NOLINT(clang-diagnostic-documentation-unknown-command)"]
pub type _INTERNAL_COMMAND = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_char,
        command_size_bytes_including_any_null_terminator: usize,
        response: *mut ::std::os::raw::c_char,
        response_size: usize,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Before issuing software or hardware triggers to get images from\n a camera, prepare it for imaging by calling tl_camera_arm.\\n\\n\n Depending on the desired trigger type, either call\n tl_camera_issue_software_trigger or issue a hardware trigger.\\n\\n\n To start a camera in continuous mode:\\n\n 1. Ensure that the camera is not armed.\\n\n 2. Set the operation mode to software triggered.\\n\n 3. Set the number of frames per trigger to 0 (which indicates continuous operation from a single trigger).\\n\n 4. Arm the camera.\\n\n 5. Issue a single software trigger. The camera will then self-trigger frames until tl_camera_disarm() is called.\\n\\n\n To start a camera for hardware triggering:\\n\n 1. Ensure that the camera is not armed.\\n\n 2. Set the operation mode to hardware or bulb triggered.\\n\n 3. Set the number of frames per trigger to 1.\\n\n 4. Set the trigger polarity to rising- or falling-edge triggering.\\n\n 5. Arm the camera.\\n\n 6. Issue a hardware-trigger signal on the trigger input.\\n\\n\n </summary>\n <param name=\"tl_camera_handle\">The handle to the camera to arm.</param>\n <param name=\"number_of_frames_to_buffer\">\n The number of frames to allocate in the internal image buffer.\n This should be set to 2 (or more), which allows one image to be transferring from the camera to the buffer while the other is being read out.\\n\\n\n </param>\n <returns>\n 0 if successful or a positive integer error code to indicate failure. In case of error, call\n tl_camera_get_last_error to get details. This error string is valid until another API called on the same thread.\n </returns>"]
pub type TL_CAMERA_ARM = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        number_of_frames_to_buffer: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Terminates the host application's connection to the specified camera.\\n\\n\n This function releases platform resources used by the camera's software abstraction and\n generally cleans up state associated with the specified camera.\n After calling this function, the specified handle is invalid and must NOT be used for\n any further camera interaction.\\n\\n\n Any attempt to do so is not permitted and could result in undefined behavior.\n </summary>\n <param name=\"tl_camera_handle\">The handle to the camera to close.</param>\n <returns>\n 0 if successful or a positive integer error code to indicate failure. In case of error, call\n tl_camera_get_last_error to get details. This error string is valid until another API called on the same thread.\n </returns>"]
pub type TL_CAMERA_CLOSE_CAMERA = ::std::option::Option<
    unsafe extern "C" fn(tl_camera_handle: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Releases any platform resources that were used by the SDK and generally cleans up SDK state.\\n\\n\n This function must be called by the user application prior to exiting.\\n\\n\n Any attempt to call an API function after this function has been called\n is not permitted and could result in undefined behavior.\\n\\n\n </summary>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_CLOSE_SDK =
    ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
#[doc = " <summary>\n Enables the user application to register for notifications of device connect events.\\n\\n\n The SDK will invoke the registered callback function every time a device is connected to the computer.\n </summary>\n <param name=\"cameraSerialNumber\">The serial number of the connected device.</param>\n <param name=\"usb_port_type\">The USB port type that the device was connected to.</param>\n <param name=\"context\">A pointer to a user specified context.  This parameter is ignored by the SDK.</param>"]
pub type TL_CAMERA_CONNECT_CALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        cameraSerialNumber: *mut ::std::os::raw::c_char,
        usb_port_type: TL_CAMERA_USB_PORT_TYPE,
        context: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " <summary>\n     Converts the decibel value received from tl_camera_convert_gain_to_decibels back into a gain index value.\n     This function will return the closest index to the specified decibel gain.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle.</param>\n <param name=\"gain_dB\">The decibel value to convert.</param>\n <param name=\"index_of_gain_value\">A reference to receive the gain index value.</param>\n <returns>\n     0 if successful or a positive integer error code to indicate failure. In case of error, call\n     tl_camera_get_last_error to get details. This error string is valid until another API called on the same thread.\n </returns>"]
pub type TL_CAMERA_CONVERT_DECIBELS_TO_GAIN = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        gain_dB: f64,
        index_of_gain_value: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n     The gain value is set in the camera with tl_camera_set_gain. It is retrieved from the camera with tl_camera_get_gain.\n     The range of possible gain values varies by camera model. It can be retrieved from the camera with tl_camera_get_gain_range.\n     The gain value units vary by camera model, but with this conversion function, it can be converted to decibels (dB).\n     A gain range of 0 to 0 means that the camera model does not support setting gain.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle.</param>\n <param name=\"index_of_gain_value\">The gain value returned by tl_camera_get_gain.</param>\n <param name=\"gain_dB\">A reference to receive the gain value in decibels (dB).</param>\n <returns>\n     0 if successful or a positive integer error code to indicate failure. In case of error, call\n     tl_camera_get_last_error to get details. This error string is valid until another API called on the same thread.\n </returns>"]
pub type TL_CAMERA_CONVERT_GAIN_TO_DECIBELS = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        index_of_gain_value: ::std::os::raw::c_int,
        gain_dB: *mut f64,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n When finished issuing software or hardware triggers, call\n tl_camera_disarm(). This will cause a camera in continuous image delivery\n mode to stop delivering images and will reset the camera's internal image\n delivery state.\\n\\n\n This allows setting parameters are are not available\n in armed mode such as ROI and binning.\\n\\n\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the disarm request.</param>\n <returns>\n 0 if successful or a positive integer error code to indicate failure. In case of error, call\n tl_camera_get_last_error to get details. This error string is valid until another API called on the same thread.\n </returns>"]
pub type TL_CAMERA_DISARM = ::std::option::Option<
    unsafe extern "C" fn(tl_camera_handle: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Enables the user application to register for notifications of device disconnect events.\\n\\n\n The SDK will invoke the registered callback function every time a device is disconnected from the computer.\n </summary>\n <param name=\"cameraSerialNumber\">The serial number of the disconnected device.</param>\n <param name=\"context\">A pointer to a user specified context.  This parameter is ignored by the SDK.</param>"]
pub type TL_CAMERA_DISCONNECT_CALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        cameraSerialNumber: *mut ::std::os::raw::c_char,
        context: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " <summary>\n Returns a space character delimited list of detected camera serial numbers.\\n\\n\n This step is required before opening a camera even if the serial number is already known.\\n\\n\n </summary>\n <param name=\"serial_numbers\">A pointer to a character string to receive the serial number list.</param>\n <param name=\"str_length\">The size in bytes of the character buffer specified in the serial_numbers parameter.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_DISCOVER_AVAILABLE_CAMERAS = ::std::option::Option<
    unsafe extern "C" fn(
        serial_numbers: *mut ::std::os::raw::c_char,
        str_length: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n <para>Register a callback function for notifications of frame (image) availability.</para>\n <para>NOTE: There are two methods for getting image frames from the camera: Polling or registering for a callback.</para>\n <para>1. Poll with the tl_camera_get_pending_frame_or_null function, typically from the main thread (polling from any thread is valid).</para>\n <para>2. Register for a callback. In this case, frames will arrive on a worker thread to avoid interrupting the main thread. Be sure to use proper thread-locking techniques if the data needs to be marshaled from the worker thread to the main thread (such as for display in a graphical user interface).</para>\n <para>The SDK will invoke the registered callback function every time an image is received from the camera.</para>\n <para>IMPORTANT: The memory is allocate inside the camera SDK. The provided pointer is only valid for the duration of this callback. Either complete copy the data before returning from this callback or complete all tasks related to the image before returning.</para>\n <para>The data for both color and monochrome cameras are ordered left to right across a row followed by the\n next row below it.</para>\n <para>For monochrome and color cameras, each pixel requires two bytes.</para>\n <para>For color cameras, it is necessary to demosaic the image in order to get\n separate blue, red, and green channels for each pixel. A performant\n demosaic algorithm is provided in tl_mono_to_color_create_mono_to_color_processor().\n Once demosaicked, each pixel requires two bytes for blue followed by two bytes\n for green followed by two bytes for red (BBGGRRBBGGRRBBGGRR...).\n Therefore, each color pixel requires six bytes. See the example color\n applications for details on converting a monochrome mosaicked\n image to a color demosaicked image.</para>\n <param name=\"tl_camera_handle_sender\">The instance of the tl_camera sending the event.</param>\n <param name=\"image_buffer\">The pointer to the buffer that contains the image data. The byte ordering of the data in this buffer is little-endian.  IMPORTANT: This pointer is only valid for the duration of this callback.</param>\n <param name=\"frame_count\">The image count corresponding to the received image during the current acquisition run.  If the image metadata section was not found, this will be 0.</param>\n <param name=\"metadata\">The pointer to the buffer that contains the image metadata.  The byte ordering of the data in this buffer is little-endian.  If the metadata section was not found, this will be null. IMPORTANT: This pointer is only valid for the duration of this callback. For details about the metadata, please see tl_camera_get_pending_frame_or_null.</param>\n <param name=\"metadata_size_in_bytes\">The size (in bytes) of the image metadata buffer. If the metadata section was not found, this will be 0.</param>\n <param name=\"context\">A pointer to a user specified context.  This parameter is ignored by the SDK.</param>\n For more information on the image metadata format, click here: \\ref IMAGE_METADATA_DOCUMENTATION"]
pub type TL_CAMERA_FRAME_AVAILABLE_CALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle_sender: *mut ::std::os::raw::c_void,
        image_buffer: *mut ::std::os::raw::c_ushort,
        frame_count: ::std::os::raw::c_int,
        metadata: *mut ::std::os::raw::c_uchar,
        metadata_size_in_bytes: ::std::os::raw::c_int,
        context: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " <summary>\n     Binning sums adjacent sensor pixels into \"super pixels\". It trades\n     off spatial resolution for sensitivity and speed. For example, if a\n     sensor is 1920 by 1080 pixels and binning is set to two in the X\n     direction and two in the Y direction, the resulting image will be 960\n     by 540 pixels. Since smaller images require less data to be\n     transmitted to the host computer, binning may increase the frame\n     rate. By default, binning is set to one in both horizontal and vertical\n     directions.\\n\\n\n     Gets the current horizontal binning value for the specified camera.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the horizontal binning request.</param>\n <param name=\"binx\">A reference to receive the current horizontal binning value.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_GET_BINX = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        binx: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n     Binning sums adjacent sensor pixels into \"super pixels\". It trades\n     off spatial resolution for sensitivity and speed. For example, if a\n     sensor is 1920 by 1080 pixels and binning is set to two in the X\n     direction and two in the Y direction, the resulting image will be 960\n     by 540 pixels. Since smaller images require less data to be\n     transmitted to the host computer, binning may increase the frame\n     rate. By default, binning is set to one in both horizontal and vertical\n     directions.\\n\\n\n     Gets the range of acceptable values for the horizontal (adjacent pixels in the X direction) binning setting for the specified camera.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the horizontal binning range request.</param>\n <param name=\"hbin_min\">A reference to receive the minimum acceptable value for horizontal binning.</param>\n <param name=\"hbin_max\">A reference to receive the maximum acceptable value for horizontal binning.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_GET_BINX_RANGE = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        hbin_min: *mut ::std::os::raw::c_int,
        hbin_max: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n     Binning sums adjacent sensor pixels into \"super pixels\". It trades\n     off spatial resolution for sensitivity and speed. For example, if a\n     sensor is 1920 by 1080 pixels and binning is set to two in the X\n     direction and two in the Y direction, the resulting image will be 960\n     by 540 pixels. Since smaller images require less data to be\n     transmitted to the host computer, binning may increase the frame\n     rate. By default, binning is set to one in both horizontal and vertical\n     directions.\\n\\n\n     Gets the current vertical binning value for the specified camera.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the vertical binning request.</param>\n <param name=\"biny\">A reference to receive the current vertical binning value.</param>\n <returns>\n 0 if successful or a positive integer error code to indicate failure. In case of error, call\n tl_camera_get_last_error to get details. This error string is valid until another API called on the same thread.\n </returns>"]
pub type TL_CAMERA_GET_BINY = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        biny: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n     Binning sums adjacent sensor pixels into \"super pixels\". It trades\n     off spatial resolution for sensitivity and speed. For example, if a\n     sensor is 1920 by 1080 pixels and binning is set to two in the X\n     direction and two in the Y direction, the resulting image will be 960\n     by 540 pixels. Since smaller images require less data to be\n     transmitted to the host computer, binning may increase the frame\n     rate. By default, binning is set to one in both horizontal and vertical\n     directions.\\n\\n\n     Gets the range of acceptable values for the vertical (adjacent pixels in the Y direction) binning setting for the specified camera.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the vertical binning range request.</param>\n <param name=\"vbin_min\">A reference to receive the minimum acceptable value for vertical binning.</param>\n <param name=\"vbin_max\">A reference to receive the maximum acceptable value for vertical binning.</param>\n <returns>\n 0 if successful or a positive integer error code to indicate failure. In case of error, call\n tl_camera_get_last_error to get details. This error string is valid until another API called on the same thread.\n </returns>"]
pub type TL_CAMERA_GET_BINY_RANGE = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        vbin_min: *mut ::std::os::raw::c_int,
        vbin_max: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n The number of bits to which a pixel value is digitized on a camera.\\n\\n\n In the image data that is delivered to the host application, the\n bit depth indicates how many of the lower bits of each 16-bit value are relevant.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the pixel bit depth request.</param>\n <param name=\"pixel_bit_depth\">A reference to receive the current pixel bit depth.</param>\n <returns>\n 0 if successful or a positive integer error code to indicate failure. In case of error, call\n tl_camera_get_last_error to get details. This error string is valid until another API called on the same thread.\n </returns>"]
pub type TL_CAMERA_GET_BIT_DEPTH = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        pixel_bit_depth: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the current black level value for the specified camera.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the black level request.</param>\n <param name=\"black_level\">A reference to receive the current black level value.</param>\n <returns>\n 0 if successful or a positive integer error code to indicate failure. In case of error, call\n tl_camera_get_last_error to get details. This error string is valid until another API called on the same thread.\n </returns>"]
pub type TL_CAMERA_GET_BLACK_LEVEL = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        black_level: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the black level maximum value for the specified camera.\n If the connected camera supports BlackLevel, the BlackLevelRange will have a maximum greater than zero.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the black level command.</param>\n <param name=\"min\">A reference to receive the black level minimum value.</param>\n <param name=\"max\">A reference to receive the black level maximum value.</param>\n <returns>\n 0 if successful or a positive integer error code to indicate failure. In case of error, call\n tl_camera_get_last_error to get details. This error string is valid until another API called on the same thread.\n </returns>"]
pub type TL_CAMERA_GET_BLACK_LEVEL_RANGE = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        min: *mut ::std::os::raw::c_int,
        max: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the output color space of the camera.\n </summary>"]
pub type TL_CAMERA_GET_CAMERA_COLOR_CORRECTION_MATRIX_OUTPUT_COLOR_SPACE = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        output_color_space: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the camera sensor type.\n </summary>"]
pub type TL_CAMERA_GET_CAMERA_SENSOR_TYPE = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        camera_sensor_type: *mut TL_CAMERA_SENSOR_TYPE,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the default color correction matrix of the camera.\n </summary>"]
pub type TL_CAMERA_GET_COLOR_CORRECTION_MATRIX = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        matrix: *mut f32,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the the color filter array of the camera.\n </summary>"]
pub type TL_CAMERA_GET_COLOR_FILTER_ARRAY_PHASE = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        cfaPhase: *mut TL_COLOR_FILTER_ARRAY_PHASE,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Determine if active-cooling mode is enabled.\n Some camera models include special hardware that provides additional cooling (beyond the conventional\n passive cooling hardware) for the sensor and the internal camera chamber.\\n To determine if a camera supports\n active cooling, use tl_camera_get_is_cooling_supported().\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the cooling mode get request.</param>\n <param name=\"is_cooling_enabled\">A reference that receives the cooling mode enable status.\\n 0 (zero) for off and 1 (one) for on.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_GET_IS_COOLING_ENABLED = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        is_cooling_enabled: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the current value of the camera sensor-level data readout rate.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the data rate request.</param>\n <param name=\"data_rate\">A reference that receives the current data rate value.</param>\n <returns>\n 0 if successful or a positive integer error code to indicate failure. In case of error, call\n tl_camera_get_last_error to get details. This error string is valid until another API called on the same thread.\n </returns>"]
pub type TL_CAMERA_GET_DATA_RATE = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        data_rate: *mut TL_CAMERA_DATA_RATE,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the default white balance matrix of the camera.\n </summary>"]
pub type TL_CAMERA_GET_DEFAULT_WHITE_BALANCE_MATRIX = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        matrix: *mut f32,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Returns the current camera exposure value in microseconds.\\n\\n\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the exposure request.</param>\n <param name=\"exposure_time_us\">A reference to receive the integer exposure value in microseconds.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_GET_EXPOSURE_TIME = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        exposure_time_us: *mut ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Returns the range of supported exposure values in whole microseconds for the specified camera.\\n\\n\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the exposure range request.</param>\n <param name=\"exposure_time_us_min\">A reference to receive the minimum exposure value in whole microseconds supported by the specified camera.</param>\n <param name=\"exposure_time_us_max\">A reference to receive the maximum exposure value in whole microseconds supported by the specified camera.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_GET_EXPOSURE_TIME_RANGE = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        exposure_time_us_min: *mut ::std::os::raw::c_longlong,
        exposure_time_us_max: *mut ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Returns a string containing the version information for all firmware components for the specified camera.\\n\\n\n Each individual component is separated by '\\r' and '\\n' characters with a null terminator at the end of the\n collection. A char buffer of size 1024 is recommended.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the firmware version request.</param>\n <param name=\"firmware_version\">A pointer to a character string to receive the version information.</param>\n <param name=\"str_length\">The length in bytes of the firmware_version buffer.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_GET_FIRMWARE_VERSION = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        firmware_version: *mut ::std::os::raw::c_char,
        str_length: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the TL_CAMERA_FRAME_AVAILABLE_CALLBACK callback function.\\n\\n\n </summary>\n <param name=\"tl_camera_handle\">The camera handle to associate with the callback.</param>\n <param name=\"handler\">A pointer to the callback function.\\n This function must conform to the TL_CAMERA_FRAME_AVAILABLE_CALLBACK prototype.</param>"]
pub type TL_CAMERA_GET_FRAME_AVAILABLE_CALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        handler: *mut TL_CAMERA_FRAME_AVAILABLE_CALLBACK,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the current frame rate value for the specified camera.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the frame rate control request.</param>\n <param name=\"frame_rate_fps\">A reference to receive the current frame rate value in frames per second.</param>\n <returns>\n 0 if successful or a positive integer error code to indicate failure. In case of error, call\n tl_camera_get_last_error to get details. This error string is valid until another API called on the same thread.\n </returns>"]
pub type TL_CAMERA_GET_FRAME_RATE_CONTROL_VALUE = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        frame_rate_fps: *mut f64,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Returns the time, in microseconds (us), required for a frame to be exposed and read out from the sensor.\n When triggering frames, this property may be used to determine when the camera is ready to accept another\n trigger. Other factors such as the communication speed between the camera and the host computer can affect the\n maximum trigger rate.\\n\\n\n NOTE: This parameters depends on tl_camera_set_frames_per_trigger_zero_for_unlimited\n and tl_camera_set_exposure_time.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the frame time request.</param>\n <param name=\"frame_time_us\">A reference to receive the current frame_time_us value for the specified camera.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_GET_FRAME_TIME = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        frame_time_us: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Returns the current camera image poll time out value in milliseconds.\\n\\n\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the exposure request.</param>\n <param name=\"timeout_ms\">A reference to receive the time out value.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_GET_IMAGE_POLL_TIMEOUT = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        timeout_ms: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the communication interface that the camera is connected to.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the communication interface request.</param>\n <param name=\"communication_interface\">A reference that receives the COMMUNICATION_INTERFACE.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_GET_COMMUNICATION_INTERFACE = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        communication_interface: *mut TL_CAMERA_COMMUNICATION_INTERFACE,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Equal Exposure Pulse (EEP) mode is an LVTTL-level signal that is\n active between the time when all rows have been reset during rolling\n reset, and the end of the exposure time (and the beginning of rolling\n readout).  The signal can be used to control an external light source\n that will be triggered on only during the equal exposure period, providing the\n same amount of exposure for all pixels in the ROI.\\n\\n\n Please see the camera documentation for details on EEP mode.\\n\\n\n This function gets the EEP status.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the EEP request.</param>\n <param name=\"eep_status_enum\">A reference that receives the current EEP status.</param>\n <returns>\n 0 if successful or a positive integer error code to indicate failure. In case of error, call\n tl_camera_get_last_error to get details. This error string is valid until another API called on the same thread.\n </returns>"]
pub type TL_CAMERA_GET_EEP_STATUS = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        eep_status_enum: *mut TL_CAMERA_EEP_STATUS,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the range of acceptable values for the frames per trigger camera parameter.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the frames per trigger request.</param>\n <param name=\"number_of_frames_per_trigger_min\">A reference that receives the minimum valid frames per trigger value.</param>\n <param name=\"number_of_frames_per_trigger_max\">A reference that receives the maximum valid frames per trigger value.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_GET_FRAMES_PER_TRIGGER_RANGE = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        number_of_frames_per_trigger_min: *mut ::std::os::raw::c_uint,
        number_of_frames_per_trigger_max: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the number of frames per trigger.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the frames per trigger request.</param>\n <param name=\"number_of_frames_per_trigger_or_zero_for_unlimited\">A reference that receives the number of frames per trigger value.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_GET_FRAMES_PER_TRIGGER_ZERO_FOR_UNLIMITED = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        number_of_frames_per_trigger_or_zero_for_unlimited: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the range of acceptable values for the frame rate control setting for the specified camera. If the maximum is zero, then\n frame rate control is not supported in the camera.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the frame rate range request.</param>\n <param name=\"frame_rate_fps_max\">A reference to receive the maximum frame rate in frames per second. </param>\n <param name=\"frame_rate_fps_min\">A reference to receive the minimum frame rate in frames per second. </param>\n <returns>\n 0 if successful or a positive integer error code to indicate failure. In case of error, call\n tl_camera_get_last_error to get details. This error string is valid until another API called on the same thread.\n </returns>"]
pub type TL_CAMERA_GET_FRAME_RATE_CONTROL_VALUE_RANGE = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        frame_rate_fps_min: *mut f64,
        frame_rate_fps_max: *mut f64,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n     Gets the current gain value for the specified camera.\\n\\n\n     The units of measure for this value vary by camera model. To convert this\n     value to decibels (dB), use tl_camera_convert_gain_to_decibels().\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the gain request.</param>\n <param name=\"gain\">A reference to receive the current gain value.</param>\n <returns>\n 0 if successful or a positive integer error code to indicate failure. In case of error, call\n tl_camera_get_last_error to get details. This error string is valid until another API called on the same thread.\n </returns>"]
pub type TL_CAMERA_GET_GAIN = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        gain: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n     Get the range of possible gain values.\\n\\n\n     The units of measure for this value vary by camera model. To convert this\n     value to decibels (dB), use tl_camera_convert_gain_to_decibels().\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the image width range request.</param>\n <param name=\"gain_min\">A reference that receives the minimum value in dB * 10 for gain.</param>\n <param name=\"gain_max\">A reference that receives the maximum value in dB * 10 for gain.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_GET_GAIN_RANGE = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        gain_min: *mut ::std::os::raw::c_int,
        gain_max: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n This function may be used to get the current threshold value for hot-pixel correction.\\n\\n\n This value is a quantitative measure of how aggressively the camera will remove hot pixels.\\n\\n\n To determine whether the camera supports hot-pixel correction, see tl_camera_get_hot_pixel_correction_threshold_range().\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the hot pixel correction threshold command.</param>\n <param name=\"hot_pixel_correction_threshold\">A reference that receives the current value of the hot pixel correction threshold for the specified camera.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_GET_HOT_PIXEL_CORRECTION_THRESHOLD = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        hot_pixel_correction_threshold: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n This function may be used to get the range of acceptable hot pixel correction threshold values.\\n\\n\n If the maximum value is 0 (zero), that is an indication that hot pixel correction is not supported by\n the specified camera.\\n\\n\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the hot pixel correction threshold command.</param>\n <param name=\"hot_pixel_correction_threshold_min\">A reference that receives the minimum acceptable value for the hot pixel correction threshold.</param>\n <param name=\"hot_pixel_correction_threshold_max\">A reference that receives the maximum acceptable value for the hot pixel correction threshold.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_GET_HOT_PIXEL_CORRECTION_THRESHOLD_RANGE = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        hot_pixel_correction_threshold_min: *mut ::std::os::raw::c_int,
        hot_pixel_correction_threshold_max: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the current image height in pixels.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the image width request.</param>\n <param name=\"height_pixels\">A reference that receives the value in pixels for the current image height.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_GET_IMAGE_HEIGHT = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        height_pixels: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the range of possible image height values.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the image height range request.</param>\n <param name=\"image_height_pixels_min\">A reference that receives the minimum value in pixels for the image height.</param>\n <param name=\"image_height_pixels_max\">A reference that receives the maximum value in pixels for the image height.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_GET_IMAGE_HEIGHT_RANGE = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        image_height_pixels_min: *mut ::std::os::raw::c_int,
        image_height_pixels_max: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the current image width in pixels.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the image width request.</param>\n <param name=\"width_pixels\">A reference that receives the value in pixels for the current image width.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_GET_IMAGE_WIDTH = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        width_pixels: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Get the range of possible image width values.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the image width range request.</param>\n <param name=\"image_width_pixels_min\">A reference that receives the minimum value in pixels for the image width.</param>\n <param name=\"image_width_pixels_max\">A reference that receives the maximum value in pixels for the image width.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_GET_IMAGE_WIDTH_RANGE = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        image_width_pixels_min: *mut ::std::os::raw::c_int,
        image_width_pixels_max: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the camera is armed or not.\n </summary>"]
pub type TL_CAMERA_GET_IS_ARMED = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        is_armed: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the cooling is supported or not of the camera.\n </summary>"]
pub type TL_CAMERA_GET_IS_COOLING_SUPPORTED = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        is_cooling_supported: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Scientific-CCD cameras and compact-scientific cameras handle sensor-\n level data-readout speed differently.\\n\\n\n Use this method to test whether the connected camera supports a particular data rate.\\n\\n\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the data rate request.</param>\n <param name=\"data_rate\">The data rate enumeration value to check for support.</param>\n <param name=\"is_data_rate_supported\">\n An indication of whether or not the data rate value is supported.\\n\n A 1 (one) indicates that the specified data rate is supported and a 0 (zero) indicates that the specified data rate is not supported.\n </param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_GET_IS_DATA_RATE_SUPPORTED = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        data_rate: TL_CAMERA_DATA_RATE,
        is_data_rate_supported: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the EEP is supported or not of the camera.\n </summary>"]
pub type TL_CAMERA_GET_IS_EEP_SUPPORTED = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        is_eep_supported: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the status of the frame rate control.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the frame rate control request.</param>\n <param name=\"is_enabled\">A value that returns the current frame rate control status. </param>\n <returns>\n 0 if successful or a positive integer error code to indicate failure. In case of error, call\n tl_camera_get_last_error to get details. This error string is valid until another API called on the same thread.\n </returns>"]
pub type TL_CAMERA_GET_IS_FRAME_RATE_CONTROL_ENABLED = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        is_enabled: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Some scientific cameras include an LED indicator light on the back panel.\\n\\n\n This function gets the LED status.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the LED request.</param>\n <param name=\"is_led_on\">A reference that receives the LED status.\\n 0 (zero) for off and 1 (one) for on.</param>\n <returns>\n 0 if successful or a positive integer error code to indicate failure. In case of error, call\n tl_camera_get_last_error to get details. This error string is valid until another API called on the same thread.\n </returns>"]
pub type TL_CAMERA_GET_IS_LED_ON = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        is_led_on: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the LED is supported or not of the camera.\n </summary>"]
pub type TL_CAMERA_GET_IS_LED_SUPPORTED = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        is_led_supported: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Due to variability in manufacturing, some pixels have inherently higher\n dark current which manifests as abnormally bright pixels in images,\n typically visible with longer exposures. Hot-pixel correction identifies\n hot pixels and then substitutes a calculated value based on the values\n of neighboring pixels in place of hot pixels.\\n\\n\n This function may be used to get the current state of hot-pixel correction.\\n\\n\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the hot pixel correction request.</param>\n <param name=\"is_hot_pixel_correction_enabled\">\n A reference that receives the state of the hot pixel correction functionality for the specified camera.\\n\n A 0 (zero) value indicates that hot pixel correction is disabled and a 1 (one) indicates that it is enabled.\\n\\n\n </param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_GET_IS_HOT_PIXEL_CORRECTION_ENABLED = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        is_hot_pixel_correction_enabled: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the NIRBoost is supported or not of the camera.\n </summary>"]
pub type TL_CAMERA_GET_IS_NIR_BOOST_SUPPORTED = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        is_nir_boost_supported: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the operation mode of the camera.\n </summary>"]
pub type TL_CAMERA_GET_IS_OPERATION_MODE_SUPPORTED = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        operation_mode: TL_CAMERA_OPERATION_MODE,
        is_operation_mode_supported: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the tap is supported or not of the camera.\n </summary>"]
pub type TL_CAMERA_GET_IS_TAPS_SUPPORTED = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        is_taps_supported: *mut ::std::os::raw::c_int,
        tap: TL_CAMERA_TAPS,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Provides a character string that describes the most recent error that has occurred.\\n\\n\n </summary>\n <returns>\n A character string indicating the most recent error that has occurred.\n The application must NOT attempt modify or deallocate the character string.\n Any attempt to do so is not permitted and could result in undefined behavior.\n </returns>"]
pub type TL_CAMERA_GET_LAST_ERROR =
    ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_char>;
#[doc = " <summary>\n Gets the current rate of frames in frames per second that are delivered to the host computer.\n The frame rate can be affected by the performance capabilities of the host computer and\n the communication interface.\\n\\n\n     This method can be polled for updated values as needed.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the fps request.</param>\n <param name=\"frames_per_second\">A reference to receive the current fps value for the specified camera.  Note that this parameter is specified as a reference to a double precision floating point value.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_GET_MEASURED_FRAME_RATE = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        frames_per_second: *mut f64,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the camera model information.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the model info request.</param>\n <param name=\"model\">A pointer to a character buffer to receive the model information.</param>\n <param name=\"str_length\">The length in bytes of the specified character buffer.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_GET_MODEL = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        model: *mut ::std::os::raw::c_char,
        str_length: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the range of valid character string buffer lengths that must be specified to receive the camera model string.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the model info request.</param>\n <param name=\"model_min\">A reference that receives the minimum length of the model character string.</param>\n <param name=\"model_max\">A reference that receives the maximum length of the model character string.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_GET_MODEL_STRING_LENGTH_RANGE = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        model_min: *mut ::std::os::raw::c_int,
        model_max: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the camera name.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the name request.</param>\n <param name=\"name\">A pointer to a character string to receive the camera name.</param>\n <param name=\"str_length\">The length of the name character string.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_GET_NAME = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        name: *mut ::std::os::raw::c_char,
        str_length: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the range of valid character string buffer lengths that must be specified to receive or set the camera name string.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the name request.</param>\n <param name=\"name_min\">A reference that receives the minimum length of the name character string.</param>\n <param name=\"name_max\">A reference that receives the maximum length of the name character string.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_GET_NAME_STRING_LENGTH_RANGE = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        name_min: *mut ::std::os::raw::c_int,
        name_max: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Determine if near-infrared-boost mode is enabled.\n Some camera models include support for boosting the intensity of wavelengths of light in the\n near-infrared part of the spectrum.\\n To determine if a camera supports NIR-boost mode, use\n tl_camera_get_is_nir_boost_supported().\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the NIR boost get request.</param>\n <param name=\"nir_boost_enable\">A reference that receives the NIR boost enable status.\\n 0 (zero) for off and 1 (one) for on.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_GET_NIR_BOOST_ENABLE = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        nir_boost_enable: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the operation mode of the camera.\n </summary>"]
pub type TL_CAMERA_GET_OPERATION_MODE = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        operation_mode: *mut TL_CAMERA_OPERATION_MODE,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n <para>Returns the current camera frame or null.\\n\\n</para>\n <para>IMPORTANT: The memory is allocated inside the camera SDK. Therefore, the provided pointer will be set to a position in the internal buffer. Either complete all tasks related to this image or make a copy of the data before returning from this function. Once this function exits, the pointer to the image buffer becomes invalid.</para>\n <para>NOTE: There are two methods for getting image frames from the camera: Polling or registering for a callback.</para>\n <para>1. Poll with the tl_camera_get_pending_frame_or_null function, typically from the main thread (polling from any thread is valid).</para>\n <para>2. Register for a callback. In this case, frames will arrive on a worker thread to avoid interrupting the main thread. Be sure to use proper thread-locking techniques if the data needs to be marshaled from the worker thread to the main thread (such as for display in a graphical user interface).</para>\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the image request.</param>\n <param name=\"image_buffer\">The pointer to the buffer that contains the image data. The byte ordering of the data in this buffer is little-endian.  IMPORTANT: This pointer is only valid for the duration of this callback.</param>\n <para>The data for both color and monochrome cameras are ordered left to right across a row followed by the\n next row below it.</para>\n <para>For monochrome and color cameras, each pixel requires two bytes.</para>\n <para>For color cameras, it is necessary to demosaic the image in order to get\n separate blue, red, and green channels for each pixel. A performant\n demosaic algorithm is provided in tl_mono_to_color_create_mono_to_color_processor().\n Once demosaicked, each pixel requires two bytes for blue followed by two bytes\n for green followed by two bytes for red (BBGGRRBBGGRRBBGGRR...).\n Therefore, each color pixel requires six bytes. See the example color\n applications for details on converting a monochrome mosaicked\n image to a color demosaicked image.</para>\n <param name=\"frame_count\">The image count corresponding to the received image during the current acquisition run.  If the image metadata section was not found, this will be 0.</param>\n <param name=\"metadata\">The pointer to the buffer that contains the image metadata.  The byte ordering of the data in this buffer is little-endian.  If the metadata section was not found, this will be null. IMPORTANT: This pointer is only valid for the duration of this callback.</param>\n <param name=\"metadata_size_in_bytes\">The size (in bytes) of the image metadata buffer. If the metadata section was not found, this will be 0.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>\n \\anchor IMAGE_METADATA_DOCUMENTATION\n The metadata section consists of tag ID/value pairs in the following format:\\n\\n\n |------ Tag ID (4 ASCII characters [4 bytes]) -----|----- Tag data [4 bytes] -----|\\n\\n\n These pairs occur consecutively in memory for all the tags supported by the camera.\\n\\n\n To iterate over the tag/value pairs, start with the pointer to the metadata and increment by 8 bytes to go from one pair to the next. Either the size of the metadata buffer or the detection of the ENDT tag should be used to determine when to stop.\\n\\n\n The following table lists the metadata tags along with a brief description:\n\n <table>\n <caption id=\"multi_row\">Image Metadata Tag Description</caption>\n <tr><th>Tag ID<th>Description\n <tr><td>TSI\\0<td>Start of metadata tag region - the data value of this tag is always 0\n <tr><td>FCNT<td>Frame count\n <tr><td>PCKH<td>Pixel clock count - upper 32 bits\n <tr><td>PCKL<td>Pixel clock count - lower 32 bits\n <tr><td>IFMT<td>Image data format\n <tr><td>IOFF<td>Offset to pixel data in multiple of 8 bytes\n <tr><td>ENDT<td>End of metadata tag region - the data value of this tag is always 0\n </table>\n\n NOTE: Not all tags are supported (are present in the metadata tag section) by all camera models. The IFMT (Image data format) tag is not present on the Zelux or Quantalux cameras.\\n\n ### How-To: Read Tags\n The example below assumes `tl_camera_get_pending_frame_or_null()` will be called and `metadata` is not NULL. It shows one way of taking the metadata pointer and iterating over the tag / value pairs.\\n\n \\snippet examples.c read tags\n ### How-To: Calculate Relative Timestamp (nanoseconds)\n Pixel clock count can be used to get a relative timestamp using the following formula: `relative_timestamp_ns = (pixel_clock_count / timestamp_clock_frequency) * 1000000000`\\n\n  - `pixel_clock_count` can be found by combining the upper and lower pixel clock counts from the metadata: `(pixel_clock_count_upper << 32) | pixel_clock_count_lower`.\\n\n  - `timestamp_clock_frequency` can be found using the following function: `tl_camera_get_timestamp_clock_frequency()`.\\n\n  .\n This timestamp is relative to an internal timer and is recorded immediately after exposure finishes. To get the time elapsed, subtract the relative timestamp of the first frame from the relative timestamp of the last frame. If `tl_camera_get_timestamp_clock_frequency()` returns an error code, then the camera does not support relative time stamping.\\n\\n"]
pub type TL_CAMERA_GET_PENDING_FRAME_OR_NULL = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        image_buffer: *mut *mut ::std::os::raw::c_ushort,
        frame_count: *mut ::std::os::raw::c_int,
        metadata: *mut *mut ::std::os::raw::c_uchar,
        metadata_size_in_bytes: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the camera polar phase information.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the model info request.</param>\n <param name=\"polar_phase\">A pointer to a TL_POLARIZATION_PROCESSOR_POLAR_PHASE enumeration value.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_GET_POLAR_PHASE = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        polar_phase: *mut TL_POLARIZATION_PROCESSOR_POLAR_PHASE,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the current Region of Interest (ROI) values.\\n\\n\n The ROI is specified by 2 sets of x,y coordinates that establish a bounded rectangular area:\\n\n - 1 for the upper left corner\n - 1 for the lower right corner.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the ROI request.</param>\n <param name=\"upper_left_x_pixels\">A reference to receive the x coordinate of the upper left corner of the ROI.</param>\n <param name=\"upper_left_y_pixels\">A reference to receive the y coordinate of the upper left corner of the ROI.</param>\n <param name=\"lower_right_x_pixels\">A reference to receive the x coordinate of the lower right corner of the ROI.</param>\n <param name=\"lower_right_y_pixels\">A reference to receive the y coordinate of the lower right corner of the ROI.</param>\n <returns>\n 0 if successful or a positive integer error code to indicate failure. In case of error, call\n tl_camera_get_last_error to get details. This error string is valid until another API called on the same thread.\n </returns>"]
pub type TL_CAMERA_GET_ROI = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        upper_left_x_pixels: *mut ::std::os::raw::c_int,
        upper_left_y_pixels: *mut ::std::os::raw::c_int,
        lower_right_x_pixels: *mut ::std::os::raw::c_int,
        lower_right_y_pixels: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the range of acceptable values for Region of Interest (ROI) coordinates.\\n\\n\n The ROI is specified by 2 sets of x,y coordinates that establish a bounded rectangular area:\\n\n - 1 for the upper left corner\n - 1 for the lower right corner.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the ROI range request.</param>\n <param name=\"upper_left_x_pixels_min\">A reference to receive the the minimum x coordinate of the upper left corner of the ROI.</param>\n <param name=\"upper_left_y_pixels_min\">A reference to receive the the minimum y coordinate of the upper left corner of the ROI.</param>\n <param name=\"lower_right_x_pixels_min\">A reference to receive the the minimum x coordinate of the lower right corner of the ROI.</param>\n <param name=\"lower_right_y_pixels_min\">A reference to receive the the minimum y coordinate of the lower right corner of the ROI.</param>\n <param name=\"upper_left_x_pixels_max\">A reference to receive the the maximum x coordinate of the upper left corner of the ROI.</param>\n <param name=\"upper_left_y_pixels_max\">A reference to receive the the maximum y coordinate of the upper left corner of the ROI.</param>\n <param name=\"lower_right_x_pixels_max\">A reference to receive the the maximum x coordinate of the lower right corner of the ROI.</param>\n <param name=\"lower_right_y_pixels_max\">A reference to receive the the maximum y coordinate of the lower right corner of the ROI.</param>\n <returns>\n 0 if successful or a positive integer error code to indicate failure. In case of error, call\n tl_camera_get_last_error to get details. This error string is valid until another API called on the same thread.\n </returns>"]
pub type TL_CAMERA_GET_ROI_RANGE = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        upper_left_x_pixels_min: *mut ::std::os::raw::c_int,
        upper_left_y_pixels_min: *mut ::std::os::raw::c_int,
        lower_right_x_pixels_min: *mut ::std::os::raw::c_int,
        lower_right_y_pixels_min: *mut ::std::os::raw::c_int,
        upper_left_x_pixels_max: *mut ::std::os::raw::c_int,
        upper_left_y_pixels_max: *mut ::std::os::raw::c_int,
        lower_right_x_pixels_max: *mut ::std::os::raw::c_int,
        lower_right_y_pixels_max: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the sensor height in pixels.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the sensor height request.</param>\n <param name=\"height_pixels\">A reference that receives the value in pixels for the sensor height.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_GET_SENSOR_HEIGHT = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        height_pixels: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Get the physical height, in micrometers, of a single light-sensitive photo site on the sensor.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the pixel height request.</param>\n <param name=\"pixel_height_um\">A reference to receive the current pixel height value in micrometers.</param>\n <returns>\n 0 if successful or a positive integer error code to indicate failure. In case of error, call\n tl_camera_get_last_error to get details. This error string is valid until another API called on the same thread.\n </returns>"]
pub type TL_CAMERA_GET_SENSOR_PIXEL_HEIGHT = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        pixel_height_um: *mut f64,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Get the current pixel size in bytes.  This represents the amount of space 1 pixel will occupy in the frame buffer.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the pixel size request.</param>\n <param name=\"sensor_pixel_size_bytes\">A reference to receive the current pixel size value in bytes.</param>\n <returns>\n 0 if successful or a positive integer error code to indicate failure. In case of error, call\n tl_camera_get_last_error to get details. This error string is valid until another API called on the same thread.\n </returns>"]
pub type TL_CAMERA_GET_SENSOR_PIXEL_SIZE_BYTES = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        sensor_pixel_size_bytes: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Get the physical width, in micrometers, of a single light-sensitive photo site on the sensor.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the pixel width request.</param>\n <param name=\"pixel_width_um\">A reference to receive the current pixel width value in micrometers.</param>\n <returns>\n 0 if successful or a positive integer error code to indicate failure. In case of error, call\n tl_camera_get_last_error to get details. This error string is valid until another API called on the same thread.\n </returns>"]
pub type TL_CAMERA_GET_SENSOR_PIXEL_WIDTH = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        pixel_width_um: *mut f64,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the send readout time for the specified camera.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the sensor readout time request.</param>\n <param name=\"sensor_readout_time_ns\">A reference to receive the current send readout time value in nanoseconds.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_GET_SENSOR_READOUT_TIME = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        sensor_readout_time_ns: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the sensor width in pixels.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the sensor width request.</param>\n <param name=\"width_pixels\">A reference that receives the value in pixels for the sensor width.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_GET_SENSOR_WIDTH = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        width_pixels: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the camera serial number.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the serial number request.</param>\n <param name=\"serial_number\">A pointer to a character string to receive the camera serial number.</param>\n <param name=\"str_length\">The length of the serial number character string.</param>\n <returns>\n 0 if successful or a positive integer error code to indicate failure. In case of error, call\n tl_camera_get_last_error to get details. This error string is valid until another API called on the same thread.\n </returns>"]
pub type TL_CAMERA_GET_SERIAL_NUMBER = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        serial_number: *mut ::std::os::raw::c_char,
        str_length: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the range of valid character string buffer lengths that must be specified to receive the camera serial number string.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the serial number range request.</param>\n <param name=\"serial_number_min\">A reference that receives the minimum length of the serial number character string.</param>\n <param name=\"serial_number_max\">A reference that receives the maximum length of the serial number character string.</param>\n <returns>\n 0 if successful or a positive integer error code to indicate failure. In case of error, call\n tl_camera_get_last_error to get details. This error string is valid until another API called on the same thread.\n </returns>"]
pub type TL_CAMERA_GET_SERIAL_NUMBER_STRING_LENGTH_RANGE = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        serial_number_min: *mut ::std::os::raw::c_int,
        serial_number_max: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the value of the current camera tap balance setting.\n The higher frame rates enabled by multi-tap operation are not without tradeoffs.\n Since each tap has a different analog to digital converter with a different gain,\n this difference can manifest in the image by each half (or quadrant) having slightly different\n intensities. The tap balance feature mitigates this effect across a wide range of exposure, gain,\n and black level values.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the taps request.</param>\n <param name=\"taps_balance_enable\">A reference that receives the tap balance enable status.\\n 0 (zero) for off and 1 (one) for on.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_GET_TAP_BALANCE_ENABLE = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        taps_balance_enable: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the current camera taps value.\n Scientific CCD cameras support one or more taps.\\n\\n\n After exposure is complete, a CCD pixel array holds the charge corresponding to the amount of light collected at\n each pixel location. The data is then read out through 1, 2, or 4 channels at a time.\n Reading the data through more than 1 channel (for cameras that support multi-tap operation) can\n enable higher maximum frame rates.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the taps request.</param>\n <param name=\"taps\">A pointer to a TL_CAMERA_TAPS enumeration value.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_GET_TAPS = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        taps: *mut TL_CAMERA_TAPS,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the timestamp clock frequency for the camera in Hz. This can be used along with the\n clock count value in each frame's metadata to calculate the relative time from plug for that frame.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the timestamp clock frequency request.</param>\n <param name=\"timestamp_clock_frequency_hz_or_zero\">A reference to receive the current time stamp clock frequency value in Hz or zero if unsupported.</param>\n <returns>\n 0 if successful or a positive integer error code to indicate failure. In case of error, call\n tl_camera_get_last_error to get details. This error string is valid until another API called on the same thread.\n </returns>"]
pub type TL_CAMERA_GET_TIMESTAMP_CLOCK_FREQUENCY = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        timestamp_clock_frequency_hz_or_zero: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the current hardware trigger polarity of the specified camera.\\n\\n\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the hardware trigger mode request.</param>\n <param name=\"trigger_polarity_enum\">A reference to a TRIGGER_POLARITY to receive the currently configured trigger polarity.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_GET_TRIGGER_POLARITY = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        trigger_polarity_enum: *mut TL_CAMERA_TRIGGER_POLARITY,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the USB port type that the camera is connected to.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the USB port type request.</param>\n <param name=\"usb_port_type\">A reference that receives the USB port type.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_GET_USB_PORT_TYPE = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        usb_port_type: *mut TL_CAMERA_USB_PORT_TYPE,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n     Read on-camera, non-volatile memory that is available to the user.\\n\\n\n     Use tl_camera_get_user_memory_maximum_size to query the available memory.\n     <param name=\"tl_camera_handle\">The camera handle associated with the USB port type request.</param>\n     <param name=\"destination_data_buffer\">A byte buffer in which to receive the specified number of bytes.</param>\n     <param name=\"number_of_bytes_to_read\">The number of bytes of user memory to read.</param>\n     <param name=\"camera_user_memory_offset_bytes\">A byte offset in the on-camera, non-volatile memory from which to start reading.\\n\\n\n         Use a value of zero to read from the beginning of user memory.\n     </param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>\n <seealso cref=\"TL_CAMERA_GET_USER_MEMORY_MAXIMUM_SIZE\" />\n <seealso cref=\"TL_CAMERA_SET_USER_MEMORY\" />\n </summary>"]
pub type TL_CAMERA_GET_USER_MEMORY = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        destination_data_buffer: *mut ::std::os::raw::c_uchar,
        number_of_bytes_to_read: ::std::os::raw::c_longlong,
        camera_user_memory_offset_bytes: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n     Gets the number of bytes of on-camera, non-volatile memory storage available to the user.\n     <param name=\"tl_camera_handle\">The camera handle associated with the USB port type request.</param>\n     <param name=\"maximum_size_bytes\">A reference that receives the 64-bit number of available bytes.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>\n </summary>"]
pub type TL_CAMERA_GET_USER_MEMORY_MAXIMUM_SIZE = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        maximum_size_bytes: *mut ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " This function will generate a trigger through the camera SDK\n rather than through the hardware trigger input.\\n\\n\n The behavior of a software trigger\n depends on the number of frames configured using tl_camera_set_number_of_frames_per_trigger.\\n\n - If the number of frames per trigger is set to zero, then a single\n   software trigger will start continuous-video mode.\\n\\n\n - If the number of frames per trigger is set to one or higher, then\n   one software trigger will generate the requested number of frames. In this\n   case, it is important to avoid issuing subsequent software triggers until\n   the time specified by tl_camera_get_frame_time multiplied by the number of frames has elapsed.\n   If insufficient time elapses, the trigger is ignored by the camera.\\n\n   NOTE: Some versions of camera firmware exhibit a longer frame time than is ideal.\n   Please check the website for the latest available firmware.\\n\\n\n Multiple software triggers can be issued before calling Disarm().\\n\\n\n See also tl_camera_get_frame_time, tl_camera_get_exposure_time, and tl_camera_get_sensor_readout_time.\n <param name=\"tl_camera_handle\">The camera handle for issuing a software trigger.</param>\n <returns>\n 0 if successful or a positive integer error code to indicate failure. In case of error, call\n tl_camera_get_last_error to get details. This error string is valid until another API called on the same thread.\n </returns>"]
pub type TL_CAMERA_ISSUE_SOFTWARE_TRIGGER = ::std::option::Option<
    unsafe extern "C" fn(tl_camera_handle: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets a handle to a camera with the specified serial number.\\n\\n\n The handle represents the software abstraction of the physical camera.\\n\\n\n The returned handle must be used with most API functions\n to perform the camera specific task corresponding to the particular function.\n </summary>\n <param name=\"camera_serial_number\">The camera serial number.</param>\n <param name=\"tl_camera_handle\">A reference to receive the handle to the camera with the specified serial number.</param>\n <returns>\n 0 if successful or a positive integer error code to indicate failure. In case of error, call\n tl_camera_get_last_error to get details. This error string is valid until another API called on the same thread.\n </returns>"]
pub type TL_CAMERA_OPEN_CAMERA = ::std::option::Option<
    unsafe extern "C" fn(
        camera_serial_number: *mut ::std::os::raw::c_char,
        tl_camera_handle: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n The tl_camera_open_sdk function is used to initialize the SDK.  This function must be called prior to calling any other API function.\\n\\n\n </summary>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_OPEN_SDK =
    ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
#[doc = " <summary>\n     Binning sums adjacent sensor pixels into \"super pixels\". It trades\n     off spatial resolution for sensitivity and speed. For example, if a\n     sensor is 1920 by 1080 pixels and binning is set to two in the X\n     direction and two in the Y direction, the resulting image will be 960\n     by 540 pixels. Since smaller images require less data to be\n     transmitted to the host computer, binning may increase the frame\n     rate. By default, binning is set to one in both horizontal and vertical\n     directions.\\n\\n\n     Sets the current horizontal binning value for the specified camera.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the horizontal binning command.</param>\n <param name=\"binx\">A value that is used to configure the horizontal binning setting.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_SET_BINX = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        binx: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n     Binning sums adjacent sensor pixels into \"super pixels\". It trades\n     off spatial resolution for sensitivity and speed. For example, if a\n     sensor is 1920 by 1080 pixels and binning is set to two in the X\n     direction and two in the Y direction, the resulting image will be 960\n     by 540 pixels. Since smaller images require less data to be\n     transmitted to the host computer, binning may increase the frame\n     rate. By default, binning is set to one in both horizontal and vertical\n     directions.\\n\\n\n     Sets the current vertical binning value for the specified camera.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the vertical binning command.</param>\n <param name=\"biny\">A value that is used to configure the vertical binning setting.</param>\n <returns>\n 0 if successful or a positive integer error code to indicate failure. In case of error, call\n tl_camera_get_last_error to get details. This error string is valid until another API called on the same thread.\n </returns>"]
pub type TL_CAMERA_SET_BINY = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        biny: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Sets the black level value for the specified camera.\n To determine if a camera model supports range, see tl_camera_get_black_level_range().\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the black level command.</param>\n <param name=\"black_level\">A value that is used to configure the black level setting.</param>\n <returns>\n 0 if successful or a positive integer error code to indicate failure. In case of error, call\n tl_camera_get_last_error to get details. This error string is valid until another API called on the same thread.\n </returns>"]
pub type TL_CAMERA_SET_BLACK_LEVEL = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        black_level: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Sets the TL_CAMERA_CONNECT_CALLBACK callback function.\\n\\n\n </summary>\n <param name=\"handler\">A pointer to the callback function.\\n This function must conform to the TL_CAMERA_CONNECT_CALLBACK prototype.</param>\n <param name=\"context\">A pointer to a user specified context.  This parameter is ignored by the SDK.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_SET_CAMERA_CONNECT_CALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        handler: TL_CAMERA_CONNECT_CALLBACK,
        context: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Sets the TL_CAMERA_DISCONNECT_CALLBACK callback function.\\n\\n\n </summary>\n <param name=\"handler\">A pointer to the callback function.\\n This function must conform to the TL_CAMERA_DISCONNECT_CALLBACK prototype.</param>\n <param name=\"context\">A pointer to a user specified context.  This parameter is ignored by the SDK.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_SET_CAMERA_DISCONNECT_CALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        handler: TL_CAMERA_DISCONNECT_CALLBACK,
        context: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Sets the current value of the camera sensor-level data readout rate.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the data rate request.</param>\n <param name=\"data_rate\">The data rate value to set.</param>\n <returns>\n 0 if successful or a positive integer error code to indicate failure. In case of error, call\n tl_camera_get_last_error to get details. This error string is valid until another API called on the same thread.\n </returns>"]
pub type TL_CAMERA_SET_DATA_RATE = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        data_rate: TL_CAMERA_DATA_RATE,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Sets the specified camera's exposure to a value which must be specified in microseconds.\\n\\n\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the exposure change.</param>\n <param name=\"exposure_time_us\">A whole number of microseconds which represents the new exposure value.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_SET_EXPOSURE_TIME = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        exposure_time_us: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n <para>Sets the TL_CAMERA_FRAME_AVAILABLE_CALLBACK callback function.</para>\n <para>NOTE: There are two methods for getting image frames from the camera: Polling or registering for a callback.</para>\n <para>1. Poll with the tl_camera_get_pending_frame_or_null function, typically from the main thread (polling from any thread is valid).</para>\n <para>2. Register for a callback. In this case, frames will arrive on a worker thread to avoid interrupting the main thread. Be sure to use proper thread-locking techniques if the data needs to be marshaled from the worker thread to the main thread (such as for display in a graphical user interface).</para>\n <para>For details, please see the documentation for TL_CAMERA_FRAME_AVAILABLE_CALLBACK.</para>\n </summary>\n <param name=\"tl_camera_handle\">The camera handle to associate with the callback.</param>\n <param name=\"handler\">A pointer to the callback function.\\n This function must conform to the TL_CAMERA_FRAME_AVAILABLE_CALLBACK prototype.</param>\n <param name=\"context\">A pointer to a user specified context.  This parameter is ignored by the SDK.</param>"]
pub type TL_CAMERA_SET_FRAME_AVAILABLE_CALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        handler: TL_CAMERA_FRAME_AVAILABLE_CALLBACK,
        context: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Sets the frame rate value in frames per second for the specified camera.\n To determine if frame-rate control is supported by a camera model, see tl_camera_get_frame_rate_control_value_range().\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the frame rate control request.</param>\n <param name=\"frame_rate_fps\">A value that is used to configure the frame rate setting in frames per second. </param>\n <returns>\n 0 if successful or a positive integer error code to indicate failure. In case of error, call\n tl_camera_get_last_error to get details. This error string is valid until another API called on the same thread.\n </returns>"]
pub type TL_CAMERA_SET_FRAME_RATE_CONTROL_VALUE = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        frame_rate_fps: f64,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Sets the number of frames per trigger.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the frames per trigger request.</param>\n <param name=\"number_of_frames_per_trigger_or_zero_for_unlimited\">The number of frames per trigger value to set.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_SET_FRAMES_PER_TRIGGER_ZERO_FOR_UNLIMITED = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        number_of_frames_per_trigger_or_zero_for_unlimited: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n     Sets the current gain value for the specified camera. To determine if a camera supports gain, see tl_camera_get_gain_range().\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the gain command.</param>\n <param name=\"gain\">A value that is used to configure the gain setting.</param>\n <returns>\n 0 if successful or a positive integer error code to indicate failure. In case of error, call\n tl_camera_get_last_error to get details. This error string is valid until another API called on the same thread.\n </returns>"]
pub type TL_CAMERA_SET_GAIN = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        gain: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n This function may be used to set the current threshold value for hot-pixel correction.\\n\\n\n This value is a quantitative measure of how aggressively the camera will remove hot pixels.\\n\\n\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the hot pixel correction threshold command.</param>\n <param name=\"hot_pixel_correction_threshold\">A reference that specifies the current value of the hot pixel correction threshold for the specified camera.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_SET_HOT_PIXEL_CORRECTION_THRESHOLD = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        hot_pixel_correction_threshold: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Sets the current camera image poll time out value in milliseconds.\\n\\n\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the exposure request.</param>\n <param name=\"timeout_ms\">The time out value to be set.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_SET_IMAGE_POLL_TIMEOUT = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        timeout_ms: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Enables or disables the EEP operating mode.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the EEP request.</param>\n <param name=\"is_eep_enabled\">A value that enables or disables EEP.  0 (zero) to disable EEP and 1 (one) to enable EEP.</param>\n <returns>\n 0 if successful or a positive integer error code to indicate failure. In case of error, call\n tl_camera_get_last_error to get details. This error string is valid until another API called on the same thread.\n </returns>"]
pub type TL_CAMERA_SET_IS_EEP_ENABLED = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        is_eep_enabled: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Enables or disables frame rate control.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the frame rate control request.</param>\n <param name=\"is_enabled\">A value that enables or disables frame rate control.  0 (zero) to disable frame rate control and 1 (one) to enable frame rate control. </param>\n <returns>\n 0 if successful or a positive integer error code to indicate failure. In case of error, call\n tl_camera_get_last_error to get details. This error string is valid until another API called on the same thread.\n </returns>"]
pub type TL_CAMERA_SET_IS_FRAME_RATE_CONTROL_ENABLED = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        is_enabled: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n This function may be used to set the current state of hot-pixel correction.\\n\\n\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the hot pixel correction command.</param>\n <param name=\"is_hot_pixel_correction_enabled\">\n A value that specifies the state of the hot pixel correction functionality for the specified camera.\n A 0 (zero) value disables hot pixel correction and a 1 (one) enables hot pixel correction.\\n\\n\n </param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_SET_IS_HOT_PIXEL_CORRECTION_ENABLED = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        is_hot_pixel_correction_enabled: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Some scientific cameras include an LED indicator light on the back panel.\\n\\n\n This function sets the LED.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the LED request.</param>\n <param name=\"is_led_on\">A value that controls the LED.\\n 0 (zero) for off and 1 (one) for on.</param>\n <returns>\n 0 if successful or a positive integer error code to indicate failure. In case of error, call\n tl_camera_get_last_error to get details. This error string is valid until another API called on the same thread.\n </returns>"]
pub type TL_CAMERA_SET_IS_LED_ON = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        is_led_on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Sets the camera name.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the name request.</param>\n <param name=\"name\">A pointer to a character string containing the new camera name.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_SET_NAME = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        name: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Enable or disable near-infrared-boost mode.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the cooling mode set request.</param>\n <param name=\"nir_boost_enable\">A value that enables/disables NIR boost mode.\\n 0 (zero) for off and 1 (one) for on.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_SET_NIR_BOOST_ENABLE = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        nir_boost_enable: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Gets the operation mode of the camera.\n </summary>"]
pub type TL_CAMERA_SET_OPERATION_MODE = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        operation_mode: TL_CAMERA_OPERATION_MODE,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Sets the current Region of Interest (ROI) values.\\n\\n\n The ROI is specified by 2 sets of x,y coordinates that establish a bounded rectangular area:\\n\n - 1 for the upper left corner\n - 1 for the lower right corner.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the ROI request.</param>\n <param name=\"upper_left_x_pixels\">The x coordinate of the upper left corner of the ROI.</param>\n <param name=\"upper_left_y_pixels\">The y coordinate of the upper left corner of the ROI.</param>\n <param name=\"lower_right_x_pixels\">The x coordinate of the lower right corner of the ROI.</param>\n <param name=\"lower_right_y_pixels\">The y coordinate of the lower right corner of the ROI.</param>\n <returns>\n 0 if successful or a positive integer error code to indicate failure. In case of error, call\n tl_camera_get_last_error to get details. This error string is valid until another API called on the same thread.\n </returns>"]
pub type TL_CAMERA_SET_ROI = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        upper_left_x_pixels: ::std::os::raw::c_int,
        upper_left_y_pixels: ::std::os::raw::c_int,
        lower_right_x_pixels: ::std::os::raw::c_int,
        lower_right_y_pixels: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Sets the camera tap balance value.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the taps request.</param>\n <param name=\"taps_balance_enable\">A value that enables/disables the tap balance feature.\\n 0 (zero) for off and 1 (one) for on.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_SET_TAP_BALANCE_ENABLE = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        taps_balance_enable: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Sets the camera taps value.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the taps request.</param>\n <param name=\"taps\">A TL_CAMERA_TAPS enumeration value.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_SET_TAPS = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        taps: TL_CAMERA_TAPS,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n Sets the current hardware trigger polarity for the specified camera.\n </summary>\n <param name=\"tl_camera_handle\">The camera handle associated with the hardware trigger mode request.</param>\n <param name=\"trigger_polarity_enum\">A TRIGGER_POLARITY value that is used to configure the trigger polarity.</param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>"]
pub type TL_CAMERA_SET_TRIGGER_POLARITY = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        trigger_polarity_enum: TL_CAMERA_TRIGGER_POLARITY,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " <summary>\n     Write to the on-camera, non-volatile memory that is available to the user.\\n\\n\n     Use tl_camera_get_user_memory_maximum_size to query the available memory.\\n\\n\n     Non-volatile memory can handle many writes, but the total number of writes is finite. Avoid unnecessary writes.\n     <param name=\"tl_camera_handle\">The camera handle associated with the USB port type request.</param>\n     <param name=\"source_data_buffer\">A byte buffer from which to write up to the specified number of bytes.</param>\n     <param name=\"number_of_bytes_to_write\">The number of bytes of the given data buffer to write at the given offset into on-camera, non-volatile, user-store memory.</param>\n     <param name=\"camera_user_memory_offset_bytes\">A byte offset in the on-camera, non-volatile memory from which to start reading.\\n\\n\n         Use a value of zero to read from the beginning of user memory.\n     </param>\n <returns>0 if successful or a positive integer error code to indicate failure.</returns>\n <seealso cref=\"TL_CAMERA_GET_USER_MEMORY_MAXIMUM_SIZE\" />\n <seealso cref=\"TL_CAMERA_GET_USER_MEMORY\" />\n </summary>"]
pub type TL_CAMERA_SET_USER_MEMORY = ::std::option::Option<
    unsafe extern "C" fn(
        tl_camera_handle: *mut ::std::os::raw::c_void,
        source_data_buffer: *mut ::std::os::raw::c_uchar,
        number_of_bytes_to_write: ::std::os::raw::c_longlong,
        camera_user_memory_offset_bytes: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    #[doc = " @cond HIDDEN_VARIABLES"]
    pub static mut _internal_command: _INTERNAL_COMMAND;
}
unsafe extern "C" {
    pub static mut tl_camera_arm: TL_CAMERA_ARM;
}
unsafe extern "C" {
    pub static mut tl_camera_close_camera: TL_CAMERA_CLOSE_CAMERA;
}
unsafe extern "C" {
    pub static mut tl_camera_close_sdk: TL_CAMERA_CLOSE_SDK;
}
unsafe extern "C" {
    pub static mut tl_camera_disarm: TL_CAMERA_DISARM;
}
unsafe extern "C" {
    pub static mut tl_camera_convert_gain_to_decibels: TL_CAMERA_CONVERT_GAIN_TO_DECIBELS;
}
unsafe extern "C" {
    pub static mut tl_camera_convert_decibels_to_gain: TL_CAMERA_CONVERT_DECIBELS_TO_GAIN;
}
unsafe extern "C" {
    pub static mut tl_camera_discover_available_cameras: TL_CAMERA_DISCOVER_AVAILABLE_CAMERAS;
}
unsafe extern "C" {
    pub static mut tl_camera_get_binx: TL_CAMERA_GET_BINX;
}
unsafe extern "C" {
    pub static mut tl_camera_get_binx_range: TL_CAMERA_GET_BINX_RANGE;
}
unsafe extern "C" {
    pub static mut tl_camera_get_biny: TL_CAMERA_GET_BINY;
}
unsafe extern "C" {
    pub static mut tl_camera_get_biny_range: TL_CAMERA_GET_BINY_RANGE;
}
unsafe extern "C" {
    pub static mut tl_camera_get_bit_depth: TL_CAMERA_GET_BIT_DEPTH;
}
unsafe extern "C" {
    pub static mut tl_camera_get_black_level: TL_CAMERA_GET_BLACK_LEVEL;
}
unsafe extern "C" {
    pub static mut tl_camera_get_black_level_range: TL_CAMERA_GET_BLACK_LEVEL_RANGE;
}
unsafe extern "C" {
    pub static mut tl_camera_get_camera_color_correction_matrix_output_color_space:
        TL_CAMERA_GET_CAMERA_COLOR_CORRECTION_MATRIX_OUTPUT_COLOR_SPACE;
}
unsafe extern "C" {
    pub static mut tl_camera_get_camera_sensor_type: TL_CAMERA_GET_CAMERA_SENSOR_TYPE;
}
unsafe extern "C" {
    pub static mut tl_camera_get_color_correction_matrix: TL_CAMERA_GET_COLOR_CORRECTION_MATRIX;
}
unsafe extern "C" {
    pub static mut tl_camera_get_color_filter_array_phase: TL_CAMERA_GET_COLOR_FILTER_ARRAY_PHASE;
}
unsafe extern "C" {
    pub static mut tl_camera_get_communication_interface: TL_CAMERA_GET_COMMUNICATION_INTERFACE;
}
unsafe extern "C" {
    pub static mut tl_camera_get_data_rate: TL_CAMERA_GET_DATA_RATE;
}
unsafe extern "C" {
    pub static mut tl_camera_get_default_white_balance_matrix:
        TL_CAMERA_GET_DEFAULT_WHITE_BALANCE_MATRIX;
}
unsafe extern "C" {
    pub static mut tl_camera_get_eep_status: TL_CAMERA_GET_EEP_STATUS;
}
unsafe extern "C" {
    pub static mut tl_camera_get_exposure_time: TL_CAMERA_GET_EXPOSURE_TIME;
}
unsafe extern "C" {
    pub static mut tl_camera_get_exposure_time_range: TL_CAMERA_GET_EXPOSURE_TIME_RANGE;
}
unsafe extern "C" {
    pub static mut tl_camera_get_firmware_version: TL_CAMERA_GET_FIRMWARE_VERSION;
}
unsafe extern "C" {
    pub static mut tl_camera_get_frame_available_callback: TL_CAMERA_GET_FRAME_AVAILABLE_CALLBACK;
}
unsafe extern "C" {
    pub static mut tl_camera_get_frame_rate_control_value: TL_CAMERA_GET_FRAME_RATE_CONTROL_VALUE;
}
unsafe extern "C" {
    pub static mut tl_camera_get_frame_rate_control_value_range:
        TL_CAMERA_GET_FRAME_RATE_CONTROL_VALUE_RANGE;
}
unsafe extern "C" {
    pub static mut tl_camera_get_frame_time: TL_CAMERA_GET_FRAME_TIME;
}
unsafe extern "C" {
    pub static mut tl_camera_get_frames_per_trigger_range: TL_CAMERA_GET_FRAMES_PER_TRIGGER_RANGE;
}
unsafe extern "C" {
    pub static mut tl_camera_get_frames_per_trigger_zero_for_unlimited:
        TL_CAMERA_GET_FRAMES_PER_TRIGGER_ZERO_FOR_UNLIMITED;
}
unsafe extern "C" {
    pub static mut tl_camera_get_gain: TL_CAMERA_GET_GAIN;
}
unsafe extern "C" {
    pub static mut tl_camera_get_gain_range: TL_CAMERA_GET_GAIN_RANGE;
}
unsafe extern "C" {
    pub static mut tl_camera_get_hot_pixel_correction_threshold:
        TL_CAMERA_GET_HOT_PIXEL_CORRECTION_THRESHOLD;
}
unsafe extern "C" {
    pub static mut tl_camera_get_hot_pixel_correction_threshold_range:
        TL_CAMERA_GET_HOT_PIXEL_CORRECTION_THRESHOLD_RANGE;
}
unsafe extern "C" {
    pub static mut tl_camera_get_image_height: TL_CAMERA_GET_IMAGE_HEIGHT;
}
unsafe extern "C" {
    pub static mut tl_camera_get_image_height_range: TL_CAMERA_GET_IMAGE_HEIGHT_RANGE;
}
unsafe extern "C" {
    pub static mut tl_camera_get_image_poll_timeout: TL_CAMERA_GET_IMAGE_POLL_TIMEOUT;
}
unsafe extern "C" {
    pub static mut tl_camera_get_image_width: TL_CAMERA_GET_IMAGE_WIDTH;
}
unsafe extern "C" {
    pub static mut tl_camera_get_image_width_range: TL_CAMERA_GET_IMAGE_WIDTH_RANGE;
}
unsafe extern "C" {
    pub static mut tl_camera_get_is_armed: TL_CAMERA_GET_IS_ARMED;
}
unsafe extern "C" {
    pub static mut tl_camera_get_is_cooling_supported: TL_CAMERA_GET_IS_COOLING_SUPPORTED;
}
unsafe extern "C" {
    pub static mut tl_camera_get_is_data_rate_supported: TL_CAMERA_GET_IS_DATA_RATE_SUPPORTED;
}
unsafe extern "C" {
    pub static mut tl_camera_get_is_eep_supported: TL_CAMERA_GET_IS_EEP_SUPPORTED;
}
unsafe extern "C" {
    pub static mut tl_camera_get_is_frame_rate_control_enabled:
        TL_CAMERA_GET_IS_FRAME_RATE_CONTROL_ENABLED;
}
unsafe extern "C" {
    pub static mut tl_camera_get_is_hot_pixel_correction_enabled:
        TL_CAMERA_GET_IS_HOT_PIXEL_CORRECTION_ENABLED;
}
unsafe extern "C" {
    pub static mut tl_camera_get_is_led_on: TL_CAMERA_GET_IS_LED_ON;
}
unsafe extern "C" {
    pub static mut tl_camera_get_is_led_supported: TL_CAMERA_GET_IS_LED_SUPPORTED;
}
unsafe extern "C" {
    pub static mut tl_camera_get_is_nir_boost_supported: TL_CAMERA_GET_IS_NIR_BOOST_SUPPORTED;
}
unsafe extern "C" {
    pub static mut tl_camera_get_is_operation_mode_supported:
        TL_CAMERA_GET_IS_OPERATION_MODE_SUPPORTED;
}
unsafe extern "C" {
    pub static mut tl_camera_get_is_taps_supported: TL_CAMERA_GET_IS_TAPS_SUPPORTED;
}
unsafe extern "C" {
    pub static mut tl_camera_get_last_error: TL_CAMERA_GET_LAST_ERROR;
}
unsafe extern "C" {
    pub static mut tl_camera_get_measured_frame_rate: TL_CAMERA_GET_MEASURED_FRAME_RATE;
}
unsafe extern "C" {
    pub static mut tl_camera_get_model: TL_CAMERA_GET_MODEL;
}
unsafe extern "C" {
    pub static mut tl_camera_get_model_string_length_range: TL_CAMERA_GET_MODEL_STRING_LENGTH_RANGE;
}
unsafe extern "C" {
    pub static mut tl_camera_get_name: TL_CAMERA_GET_NAME;
}
unsafe extern "C" {
    pub static mut tl_camera_get_name_string_length_range: TL_CAMERA_GET_NAME_STRING_LENGTH_RANGE;
}
unsafe extern "C" {
    pub static mut tl_camera_get_nir_boost_enable: TL_CAMERA_GET_NIR_BOOST_ENABLE;
}
unsafe extern "C" {
    pub static mut tl_camera_get_operation_mode: TL_CAMERA_GET_OPERATION_MODE;
}
unsafe extern "C" {
    pub static mut tl_camera_get_pending_frame_or_null: TL_CAMERA_GET_PENDING_FRAME_OR_NULL;
}
unsafe extern "C" {
    pub static mut tl_camera_get_polar_phase: TL_CAMERA_GET_POLAR_PHASE;
}
unsafe extern "C" {
    pub static mut tl_camera_get_roi: TL_CAMERA_GET_ROI;
}
unsafe extern "C" {
    pub static mut tl_camera_get_roi_range: TL_CAMERA_GET_ROI_RANGE;
}
unsafe extern "C" {
    pub static mut tl_camera_get_sensor_height: TL_CAMERA_GET_SENSOR_HEIGHT;
}
unsafe extern "C" {
    pub static mut tl_camera_get_sensor_pixel_height: TL_CAMERA_GET_SENSOR_PIXEL_HEIGHT;
}
unsafe extern "C" {
    pub static mut tl_camera_get_sensor_pixel_size_bytes: TL_CAMERA_GET_SENSOR_PIXEL_SIZE_BYTES;
}
unsafe extern "C" {
    pub static mut tl_camera_get_sensor_pixel_width: TL_CAMERA_GET_SENSOR_PIXEL_WIDTH;
}
unsafe extern "C" {
    pub static mut tl_camera_get_sensor_readout_time: TL_CAMERA_GET_SENSOR_READOUT_TIME;
}
unsafe extern "C" {
    pub static mut tl_camera_get_sensor_width: TL_CAMERA_GET_SENSOR_WIDTH;
}
unsafe extern "C" {
    pub static mut tl_camera_get_serial_number: TL_CAMERA_GET_SERIAL_NUMBER;
}
unsafe extern "C" {
    pub static mut tl_camera_get_serial_number_string_length_range:
        TL_CAMERA_GET_SERIAL_NUMBER_STRING_LENGTH_RANGE;
}
unsafe extern "C" {
    pub static mut tl_camera_get_tap_balance_enable: TL_CAMERA_GET_TAP_BALANCE_ENABLE;
}
unsafe extern "C" {
    pub static mut tl_camera_get_taps: TL_CAMERA_GET_TAPS;
}
unsafe extern "C" {
    pub static mut tl_camera_get_timestamp_clock_frequency: TL_CAMERA_GET_TIMESTAMP_CLOCK_FREQUENCY;
}
unsafe extern "C" {
    pub static mut tl_camera_get_trigger_polarity: TL_CAMERA_GET_TRIGGER_POLARITY;
}
unsafe extern "C" {
    pub static mut tl_camera_get_usb_port_type: TL_CAMERA_GET_USB_PORT_TYPE;
}
unsafe extern "C" {
    pub static mut tl_camera_get_user_memory: TL_CAMERA_GET_USER_MEMORY;
}
unsafe extern "C" {
    pub static mut tl_camera_get_user_memory_maximum_size: TL_CAMERA_GET_USER_MEMORY_MAXIMUM_SIZE;
}
unsafe extern "C" {
    pub static mut tl_camera_issue_software_trigger: TL_CAMERA_ISSUE_SOFTWARE_TRIGGER;
}
unsafe extern "C" {
    pub static mut tl_camera_open_camera: TL_CAMERA_OPEN_CAMERA;
}
unsafe extern "C" {
    pub static mut tl_camera_open_sdk: TL_CAMERA_OPEN_SDK;
}
unsafe extern "C" {
    pub static mut tl_camera_set_binx: TL_CAMERA_SET_BINX;
}
unsafe extern "C" {
    pub static mut tl_camera_set_biny: TL_CAMERA_SET_BINY;
}
unsafe extern "C" {
    pub static mut tl_camera_set_black_level: TL_CAMERA_SET_BLACK_LEVEL;
}
unsafe extern "C" {
    pub static mut tl_camera_set_camera_connect_callback: TL_CAMERA_SET_CAMERA_CONNECT_CALLBACK;
}
unsafe extern "C" {
    pub static mut tl_camera_set_camera_disconnect_callback:
        TL_CAMERA_SET_CAMERA_DISCONNECT_CALLBACK;
}
unsafe extern "C" {
    pub static mut tl_camera_get_is_cooling_enabled: TL_CAMERA_GET_IS_COOLING_ENABLED;
}
unsafe extern "C" {
    pub static mut tl_camera_set_data_rate: TL_CAMERA_SET_DATA_RATE;
}
unsafe extern "C" {
    pub static mut tl_camera_set_exposure_time: TL_CAMERA_SET_EXPOSURE_TIME;
}
unsafe extern "C" {
    pub static mut tl_camera_set_frame_available_callback: TL_CAMERA_SET_FRAME_AVAILABLE_CALLBACK;
}
unsafe extern "C" {
    pub static mut tl_camera_set_frame_rate_control_value: TL_CAMERA_SET_FRAME_RATE_CONTROL_VALUE;
}
unsafe extern "C" {
    pub static mut tl_camera_set_frames_per_trigger_zero_for_unlimited:
        TL_CAMERA_SET_FRAMES_PER_TRIGGER_ZERO_FOR_UNLIMITED;
}
unsafe extern "C" {
    pub static mut tl_camera_set_gain: TL_CAMERA_SET_GAIN;
}
unsafe extern "C" {
    pub static mut tl_camera_set_hot_pixel_correction_threshold:
        TL_CAMERA_SET_HOT_PIXEL_CORRECTION_THRESHOLD;
}
unsafe extern "C" {
    pub static mut tl_camera_set_is_eep_enabled: TL_CAMERA_SET_IS_EEP_ENABLED;
}
unsafe extern "C" {
    pub static mut tl_camera_set_is_frame_rate_control_enabled:
        TL_CAMERA_SET_IS_FRAME_RATE_CONTROL_ENABLED;
}
unsafe extern "C" {
    pub static mut tl_camera_set_is_hot_pixel_correction_enabled:
        TL_CAMERA_SET_IS_HOT_PIXEL_CORRECTION_ENABLED;
}
unsafe extern "C" {
    pub static mut tl_camera_set_is_led_on: TL_CAMERA_SET_IS_LED_ON;
}
unsafe extern "C" {
    pub static mut tl_camera_set_image_poll_timeout: TL_CAMERA_SET_IMAGE_POLL_TIMEOUT;
}
unsafe extern "C" {
    pub static mut tl_camera_set_name: TL_CAMERA_SET_NAME;
}
unsafe extern "C" {
    pub static mut tl_camera_set_nir_boost_enable: TL_CAMERA_SET_NIR_BOOST_ENABLE;
}
unsafe extern "C" {
    pub static mut tl_camera_set_operation_mode: TL_CAMERA_SET_OPERATION_MODE;
}
unsafe extern "C" {
    pub static mut tl_camera_set_roi: TL_CAMERA_SET_ROI;
}
unsafe extern "C" {
    pub static mut tl_camera_set_tap_balance_enable: TL_CAMERA_SET_TAP_BALANCE_ENABLE;
}
unsafe extern "C" {
    pub static mut tl_camera_set_taps: TL_CAMERA_SET_TAPS;
}
unsafe extern "C" {
    pub static mut tl_camera_set_trigger_polarity: TL_CAMERA_SET_TRIGGER_POLARITY;
}
unsafe extern "C" {
    pub static mut tl_camera_set_user_memory: TL_CAMERA_SET_USER_MEMORY;
}
